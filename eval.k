;;; -*- coke -*-

;;(define-form debug prog ())
;;(define-form debug prog `(let () ,@prog))

(define-form debug prog `(if do_debug (let () ,@prog)))

(define-structure <header> (size flags next type))
(define-structure <buffer> (contents size position))

(define-function make-gc-protectors (vars)
  (map (lambda (v) (list 'gc_push_root (list 'address-of v) (symbol->string v)))
       vars))

(define-function make-gc-unprotectors (vars)
  (let ((result ()))
    (while (pair? vars)
      (set result (cons (list 'gc_pop_root (list 'address-of (car vars)) (symbol->string (car vars))) result))
      (set vars (cdr vars)))
    result))

(define-form gc-protect (vars . prog)
  `(let ()
     ,@(make-gc-protectors vars)
     (let ((__answer__ ,@prog))
       ,@(make-gc-unprotectors vars)
       __answer__)))

(compile-begin)

(define do_debug 0)

(define gc_quantum	65504)
(define gc_frequency	1);32768)

(define exit	(extern 'exit))
(define malloc	(extern 'malloc))
(define free	(extern 'free))
(define memset	(extern 'memset))
(define memcpy	(extern 'memcpy))
(define printf	(extern 'printf))

(define gc_roots	0)	(define gc_names	0)
(define gc_root_count	0)
(define gc_root_max	0)

(define gc_memory_base	0)
(define gc_memory_last	0)
(define gc_alloc_count	0)

(define-form size-of-structure (type)	(* 4 (array-at %structure-sizes (eval type))))

(define-form <header>-flags-used ()	1)
(define-form <header>-flags-atom ()	2)
(define-form <header>-flags-mark ()	4)

(define-form <header>-flags-used+atom ()	(+ (<header>-flags-used) (<header>-flags-atom)))

(define-function max (a b)	(if (> a b) a b))

(define-function fatal (reason)		(printf "\n%s\n" reason) (exit 1))

(define-function fatal1 (fmt arg)	(printf "\n") (printf fmt arg)		(printf "\n") (exit 1))
(define-function fatal2 (fmt arg brg)	(printf "\n") (printf fmt arg brg)	(printf "\n") (exit 1))

(define-function new_memory_block (size)
  (let ((ptr (malloc size)))
    (or ptr (fatal "out of memory"))
    (set (<header>-size  ptr) (- size (size-of-structure <header>)))
    (set (<header>-flags ptr) 0)
    (set (<header>-next  ptr) ptr)
    (printf "BRK %p %d %d/%d\n" ptr size gc_alloc_count gc_frequency)
    ptr))

(define-function gc_initialise ()
  (let ((ptr (new_memory_block gc_quantum)))
    (set gc_memory_base ptr)
    (set gc_memory_last ptr)))

(define-function gc_push_root (ptr name)
  (and (= gc_root_count gc_root_max)
       (let* ((roots (malloc (* 4 (set gc_root_max (max 32 (* 2 gc_root_max))))))
	      (names (malloc (* 4 gc_root_max))))
	 (memcpy roots gc_roots (* 4 gc_root_count))	(memcpy names gc_names (* 4 gc_root_count))
	 (and gc_roots (free gc_roots))			(and gc_names (free gc_names))
	 (set gc_roots roots)				(set gc_names names)
	 ))
  (set-oop-at gc_roots gc_root_count ptr)		(set-oop-at gc_names gc_root_count name)
  (debug (printf "gc add root %d at %p %s\n" gc_root_count ptr name))
  (set gc_root_count (+ 1 gc_root_count)))

(define-function gc_pop_root (ptr name)
  (or gc_root_count (fatal "root table underflow"))
  (set gc_root_count (- gc_root_count 1))
  (debug (printf "gc del root %d at %p %s\n" gc_root_count ptr name))
  (or (= ptr (oop-at gc_roots gc_root_count)) (fatal "non-lifo root")))

(define-function gc_grow_memory (size)
  (let ((brk (new_memory_block size)))
    (set (<header>-next brk)            (<header>-next gc_memory_last))
    (set (<header>-next gc_memory_last) brk)))

(define-function gc_size (obj)
  (<header>-size (- obj (size-of-structure <header>))))

(define-function gc_malloc_chunk (size)
  (let ((ptr   (<header>-next gc_memory_last))
	(done  ())
	(chunk ()))
    (let ((lim ptr))
      (while (not done)
	(debug (printf "alloc? %d %p %p [%p] %d >= %d %d\n" (<header>-flags ptr) ptr (<header>-next ptr) lim (<header>-size ptr) size (<= size (<header>-size ptr))))
	(if (and (=  0    (<header>-flags ptr))
		 (<= size (<header>-size  ptr)))
	    (let ()
	      (set chunk ptr)
	      (set done 1))
	  (set done (= lim (set ptr (<header>-next ptr)))))))
    (debug (printf "gc_malloc_chunk found free %p\n" chunk))
    (if chunk
	(let ((csize (<header>-size chunk)))
	  (debug (printf "csize %d\n" csize))
	  (and (> csize (+ size (size-of-structure <header>)))
	       (let ((split (+ chunk (+ (size-of-structure <header>) size))))
		 (debug (printf "split %d: %p + %d -> %p + %d\n" csize chunk size split (- csize (+ size (size-of-structure <header>)))))
		 (set (<header>-size  split) (- csize (+ size (size-of-structure <header>))))
		 (set (<header>-flags split) 0)
		 (set (<header>-next  split) (<header>-next chunk))
		 (set (<header>-size  chunk) size)
		 (set (<header>-next  chunk) split)
		 (set csize size)))
	  (set (<header>-flags chunk) (<header>-flags-used))
	  (set gc_memory_last chunk)
	  (debug (printf "alloc chunk %p\n" chunk))
	  (let ((obj (+ chunk (size-of-structure <header>))))
	    (memset obj 0 csize)
	    (set gc_alloc_count (+ gc_alloc_count 1))
	    obj)))))

(define-function gc_sweep ()
  (debug (printf "sweep\n"))
  (let ((ptr gc_memory_base)
	(nused 0)
	(nfree 0))
    (while ptr
      (debug (printf "sweep? %d %p + %d\n" (<header>-flags ptr) ptr (<header>-size ptr)))
      (let ((flags (<header>-flags ptr)))
	(if (& flags (<header>-flags-mark))
	    (let ()
	      (set nused (+ nused (<header>-size ptr)))
	      (set (<header>-flags ptr) (^ flags (<header>-flags-mark))))
	  (debug (printf "collect %p %d\n" ptr (<header>-size ptr)))
;; 	  (while (and (= 0 (& (<header>-flags-mark) (<header>-flags (<header>-next ptr))))
;; 		      (printf "%p + %d + %d = %p ? %p\n"
;; 			      ptr (size-of-structure <header>) (<header>-size ptr)
;; 			      (+ ptr (+ (size-of-structure <header>) (<header>-size ptr)))
;; 			      (<header>-next ptr))
;; 		      (= (<header>-next ptr) (+ ptr (+ (size-of-structure <header>) (<header>-size ptr)))))
;; 	    (let ((next (<header>-next (<header>-next ptr))))
;; 	      (printf "COALESCE %p < %p > %p\n" ptr (<header>-next ptr) next)
;; 	      (set (<header>-size ptr) (- (- next ptr) (size-of-structure <header>)))
;; 	      (set (<header>-next ptr) next)))
	  (set nfree (+ nfree (<header>-size ptr)))
	  (set (<header>-flags ptr) 0)))
      (and (= gc_memory_base (set ptr (<header>-next ptr)))
	   (set ptr 0)))
    ;;(printf "GC: %d used, %d free, %d allocations\n" nused nfree gc_alloc_count)
    ;;(and (< nfree nused) (gc_grow_memory gc_quantum))
    ))

(define-function gc_mark_and_trace (obj)
  (and obj
       (not (& 1 obj))
       (let* ((ptr   (- obj (size-of-structure <header>)))
	      (flags (<header>-flags ptr)))
	 (debug (printf "mark and trace %p flags %d\n" obj flags))
	 (or (& (<header>-flags-used) flags) (fatal1 "attempt to mark dead object %p" ptr))
	 (or (& flags (<header>-flags-mark))
	     (let ()
	       (or (& flags (<header>-flags-atom))
		   (let ((size (>> (<header>-size ptr) 2)))
		     (debug (printf "mark %p %d type %d\n" ptr size (<header>-type ptr)))
		     (while size
		       (set size (- size 1))
		       (debug (printf "@%d %p\n" size (oop-at obj size)))
		       (gc_mark_and_trace (oop-at obj size)))))
	       (set (<header>-flags ptr) (| flags (<header>-flags-mark))))))))

(define-function gc_gcollect ()
  (let ((i 0))
    (while (< i gc_root_count)
      (debug (let ((ptr (oop-at gc_roots i))) (printf "mark gc root %d %s: %p -> %p\n" i (oop-at gc_names i) ptr (oop-at ptr 0))))
      (gc_mark_and_trace (oop-at (oop-at gc_roots i) 0))
      (set i (+ 1 i))))
  (gc_sweep)
  (set gc_alloc_count 0))

(define-function gc_malloc (size)
  (set size (& -4 (+ 3 size)))
  (and (= gc_alloc_count gc_frequency) (gc_gcollect))
  (or (gc_malloc_chunk size)
      (let ()
	(gc_grow_memory (max (+ (size-of-structure <header>) size) gc_quantum))
	(gc_malloc_chunk size))
      (fatal "internal error: failed to allocate object after growing memory")))

(define-function gc_malloc_atomic (size)
  (let* ((obj (gc_malloc size)))
    (set (<header>-flags (- obj (size-of-structure <header>))) (<header>-flags-used+atom))
    obj))

;;; ----------------------------------------------------------------

(define strlen	(extern 'strlen))
(define strcmp	(extern 'strcmp))
(define strdup	(extern 'strdup))
(define strtoul	(extern 'strtoul))
(define getc	(extern 'getc))
(define putc	(extern 'putc))
(define ungetc	(extern 'ungetc))
(define fdopen	(extern 'fdopen))
(define fopen	(extern 'fopen))
(define fclose	(extern 'fclose))
(define fflush	(extern 'fflush))
(define fscanf	(extern 'fscanf))

(define stdin	0)
(define stdout	0)
(define stderr	0)

(define EOF	-1)

(define <undefined>	 0)
(define <long>		 1)
(define <string>	 2)
(define <symbol>	 3)
(define <pair>		 4)
(define <_array>	 5)
(define <array>		 6)
(define <expr>		 7)
(define <form>		 8)
(define <fixed>		 9)
(define <subr>		10)

(define symbols			0)
(define globals			0)
(define expanders		0)
(define s_set			0)
(define s_quote			0)
(define s_quasiquote		0)
(define s_unquote		0)
(define s_unquote_splicing	0)
(define s_expanders		0)

(define-function new-bits (type size)
  (let ((obj (gc_malloc_atomic size)))
    (set (oop-at obj -1) type)
    obj))

(define-function new-oops (type size)
  (let ((obj (gc_malloc size)))
    (set (oop-at obj -1) type)
    obj))

(define-function new-<long> (bits)
  (let ((obj (new-bits <long> (size-of-structure <long>))))
    (set (<long>-_bits obj) bits)
    obj))

(define-function _new-<string> (len)
  (let ((str (new-oops <string> (size-of-structure <string>))))
    (gc-protect (str)
      (set (<string>-size  str) (new-<long> len))
      (set (<string>-_bits str) (gc_malloc_atomic (+ len 1)))
      str)))

(define-function new-<string> (cstr)
  (let ((len (strlen cstr)))
    (let ((obj (_new-<string> len)))
      (memcpy (<string>-_bits obj) cstr len)
      obj)))

(define-function new-<symbol> (cstr)
  (let ((obj (new-bits <symbol> (size-of-structure <symbol>))))
    (set (<symbol>-_bits obj) (strdup cstr))
    obj))

(define-function new-<pair> (head tail)
  (let ((obj (new-oops <pair> (size-of-structure <pair>))))
    (set (<pair>-head obj) head)
    (set (<pair>-tail obj) tail)
    obj))

(define-function new-<array> (size)
(printf "A\n")
  (let ((arr (new-oops <array> (size-of-structure <array>))))
(printf "B\n")
    (gc-protect (arr)
(printf "C\n")
      (set (<array>-_array arr) (new-oops <_array> (* 4 size)))
(printf "D\n")
      arr)))

(define-form is (type arg)
  `(let ((__arg__ ,arg))
     (and __arg__
	  (not (& 1 __arg__))
	  (= ,type (oop-at __arg__ -1)))))

(define-form get-type (arg)
  `(let ((__arg__ ,arg))
     (and __arg__
	  (or (& (<header>-flags-used) (<header>-flags (- __arg__ (size-of-structure <header>))))
	      (fatal1 "attempt to access dead object %p type %d" __arg__)))
     (if __arg__
	 (oop-at __arg__ -1)
       <undefined>)))

(define-function type_check_fail (exp act)
  (fatal2 "illegal type: expected %d got %d" exp act))

(define-form get (type field object)
  `(let ((__obj__ ,object))
     (let ((t (get-type __obj__))) (or (= ,type t) (type_check_fail ,type t)))
     (,(concat-symbol (concat-symbol type '-) field) __obj__)))

(define-form put (type field object value)
  `(let ((__obj__ ,object))
     (let ((t (get-type __obj__))) (or (= ,type t) (type_check_fail ,type t)))
     (,(concat-symbol (concat-symbol (concat-symbol 'set- type) '-) field) __obj__)))

(define-form get_head (obj)	`(oop-at ,obj 0))
(define-form get_tail (obj)	`(oop-at ,obj 1))
(define-form set_tail (obj val)	`(set-oop-at ,obj 1 ,val))

(define-function is_blank (c)	(or 	 ( = ?   c)			; sp
				    	 ( = ?\t c)			; ht
				    	 ( = ?\n c)			; nl
				    	 ( = ?\v c)			; vt
				    	 ( = ?\f c)			; ff
				    	 ( = ?\r c)))			; cr

(define-function is_digit10 (c)	    (and (<= ?0  c) (<= c ?9)))		; 0 1 2 3 4 5 6 7 8 9

(define-function is_digit16 (c)	(or (and (<= ?0  c) (<= c ?9))		; 0 1 2 3 4 5 6 7 8 9
				    (and (<= ?a  c) (<= c ?f))		; a b c d e f
				    (and (<= ?A  c) (<= c ?F))))	; A B C D E F

(define-function is_alpha (c)	(or (and (<= ?a  c) (<= c ?z))		; a b c d e f g h i j k l m n o p q r s t u v w x y z
				    (and (<= ?A  c) (<= c ?Z))))	; A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

(define-function is_letter (c)	(or      ( = ?!  c)			; !
				    (and (<= ?#  c) (<= c ?&))		; # $ % &
				    (and (<= ?*  c) (<= c ?/))		; * + , - . /
					 ( = ?:  c)			; :
				    (and (<= ?<  c) (<= c ?Z))		; < = > ?  @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
					 ( = ?\\ c)			; \
					 ( = ?^  c)			; ^
					 ( = ?_  c)			; _
				    (and (<= ?a  c) (<= c ?z))		; a b c d e f g h i j k l m n o p q r s t u v w x y z
					 ( = ?|  c)			; |
					 ( = ?~  c)))			; ~

(define-function new_buffer ()
  (let ((buf (malloc (size-of-structure <buffer>))))
    (set (<buffer>-contents buf) (malloc 32))
    (set (<buffer>-size     buf) 32)
    (set (<buffer>-position buf) 0)
    buf))

(define-function buffer_delete (buf)
  (free (<buffer>-contents buf))
  (free buf))

(define-function buffer_grow (buf)
  (let* ((size     (<buffer>-size buf))
	 (contents (malloc (* 2 size))))
    (memcpy contents (<buffer>-contents buf) size)
    (free (<buffer>-contents buf))
    (set (<buffer>-contents buf) contents)
    (set (<buffer>-size buf) (* 2 size))))

(define-function buffer_append (buf c)
  (and (= (<buffer>-position buf) (<buffer>-size buf))
       (buffer_grow buf))
  (let ((posn (<buffer>-position buf)))
    (set-char-at (<buffer>-contents buf) posn c)
    (set (<buffer>-position buf) (+ 1 posn))))

(define-function buffer_append_all (buf s)
  (let ((i 0)
	(c 0))
    (while (set c (char-at s i))
      (buffer_append buf c)
      (set i (+ 1 i)))))

(define-function buffer_contents (buf)
  (buffer_append buf 0)
  (set (<buffer>-position buf) (- (<buffer>-position buf) 1))
  (<buffer>-contents buf))

(define-function intern (cstr)
  (let ((list symbols))
    (while (is <pair> list)
      (let ((sym (get_head list)))
	(or (strcmp cstr (get <symbol> _bits sym))
	    (return sym)))
      (set list (get_tail list))))
  (let ((sym (new-<symbol> cstr)))
    (gc-protect (sym)
      (set symbols (new-<pair> sym symbols))
      sym)))

(define-function is_octal (c)		(and (<= ?0 c) (<= c ?7)))

(define-function is_hexadecimal (c)	(or (and (<= ?0 c) (<= c ?9))
					    (and (<= ?a c) (<= c ?f))
					    (and (<= ?A c) (<= c ?F))))

(define-function digit_value (c)
  (cond
    ((and (<= ?0 c) (<= c ?9))	(- c ?0))
    ((and (<= ?a c) (<= c ?z))	(- c (- ?a 10)))
    ((and (<= ?A c) (<= c ?Z))	(- c (- ?A 10)))
    (else			(fatal "illegal digit in character escape"))))

(define-function read_char (c stream)
  (and (= ?\\ c)
       (let ()
	 (set c (getc stream))
	 (cond
	   ((= c ?a)			?\a)
	   ((= c ?b)			?\b)
	   ((= c ?f)			?\f)
	   ((= c ?n)			?\n)
	   ((= c ?r)			?\r)
	   ((= c ?t)			?\t)
	   ((= c ?v)			?\v)
	   ((= c ?u)			(let ((a (getc stream))
					      (b (getc stream))
					      (c (getc stream))
					      (d (getc stream)))
					  (+ (<< (digit_value a) 24)
					     (+ (<< (digit_value b) 16)
						(+ (<< (digit_value c)  8)
						   (digit_value d)    )))))
	   ((= c ?x)			(let ((x 0))
					  (if (is_hexadecimal (set c (getc stream)))
					      (let ()
						(set x (digit_value c))
						(if (is_hexadecimal (set c (getc stream)))
						    (let ()
						      (set x (+ (* x 16) (digit_value c)))
						      (set c (getc stream))))))
					  (ungetc c stream)
					  x))
	   ((and (<= ?0 c) (<= c ?7))	(let ((x (digit_value c)))
					  (if (is_octal (set c (getc stream)))
					      (let ()
						(set x (+ (* x 8) (digit_value c)))
						(if (is_octal (set c (getc stream)))
						    (let ()
						      (set x (+ (* x 8) (digit_value c)))
						      (set c (getc stream))))))
					  (ungetc c stream)
					  x))
	   (else			(if (or (is_alpha c) (is_digit10 c))
					    (fatal1 "illegal character escape: \\%c" c))))))
  c)

(define-function read_number (c stream)
  (let ((buf (new_buffer))
	(neg (= ?- c)))
    (or neg (buffer_append buf c))
    (while (is_digit10 (set c (getc stream))) (buffer_append buf c))
    (and (= ?x c) (= 1 (<buffer>-position buf))
	 (let ()
	   (buffer_append buf c)
	   (while (is_digit16 (set c (getc stream))) (buffer_append buf c))))
    (ungetc c stream)
    (buffer_append buf 0)
    (let ((result (strtoul (<buffer>-contents buf) 0 0)))
      (buffer_delete buf)
      (new-<long> (if neg (- result) result)))))

(define-function read_symbol (c stream)
  (let ((buf (new_buffer)))
    (while (or (is_letter c) (is_digit10 c))
      (buffer_append buf c)
      (set c (getc stream)))
    (ungetc c stream)
    (buffer_append buf 0)
    (let ((result (intern (<buffer>-contents buf))))
      (buffer_delete buf)
      result)))

(define-function read_string (c stream)
  (let ((buf (new_buffer)))
    (while (!= ?\" (set c (getc stream)))
      (set c (read_char c stream))
      (and (= EOF c) (fatal "unterminated string literal"))
      (buffer_append buf c))
    (buffer_append buf 0)
    (let ((result (new-<string> (<buffer>-contents buf))))
      (buffer_delete buf)
      result)))

(define-function read_list (delim stream)
  (let* ((head (new-<pair> () ()))
	 (tail head)
	 (elt  ()))
    (gc-protect (head elt)
      (gc_gcollect)
      (while (and (!= EOF (set elt (k_read stream))))
	(set elt (new-<pair> elt ()))
	(set tail (set_tail tail elt))))
    (let ((c (getc stream)))
      (if (= delim c)
	  (get_tail head)
	(fatal1 "missing closing '%c' delimiter while reading list" delim)))))

(define-function read_quote (prefix stream)
  (let ((qobj (k_read stream)))
    (and (= EOF qobj) (fatal "EOF while reading quoted literal"))
    (gc-protect (qobj)
      (set qobj (new-<pair> qobj ()))
      (set qobj (new-<pair> prefix qobj))
      qobj)))

(define-function k_read (stream)
  (while 1
    (let ((c (getc stream)))
      (cond
	((is_blank c)	())
	((= ?? c)	(return (new-<long> (read_char (getc stream) stream))))
	((= ?- c)	(return (if (is_digit10 (ungetc (getc stream) stream))
				    (read_number c stream)
				    (read_symbol c stream))))
	((= ?\' c)	(return (read_quote s_quote stream)))
	((= ?\` c)	(return (read_quote s_quasiquote stream)))
	((= ?\, c)	(return (let ((d (getc stream)))
				  (if (= ?@ d)
				      (read_quote s_unquote_splicing stream)
				    (ungetc d stream)
				    (read_quote s_unquote)))))
	((is_letter c)	(return (read_symbol c stream)))
	((= ?\( c)	(return (read_list ?\) stream)))	((= ?\) c)	(return (let () (ungetc c stream) EOF)))
	((= ?\[ c)	(return (read_list ?\] stream)))	((= ?\] c)	(return (let () (ungetc c stream) EOF)))
	((= ?\{ c)	(return (read_list ?\} stream)))	((= ?\} c)	(return (let () (ungetc c stream) EOF)))
	((is_digit10 c)	(return (read_number c stream)))
	((= ?\; c)	(while (and (!= ?\n (set c (getc stream)))
				    (!= ?\r c)
				    (!= EOF c))))
	((= ?\" c)	(return (read_string c stream)))
	((< c 0)	(return EOF))
	(else		(fatal1 "illegal character: %c" c))))))

(define-function do_print (obj storing)
  (debug (printf "{%p}" obj))
  (let ((type (get-type obj)))
    (cond
      ((= type <undefined>)	(printf "nil"))
      ((= type <long>)		(printf "%d" (get <long> _bits obj)))
      ((= type <string>)	(let ((bits (get <string> _bits obj)))
				  (if (not storing)
				      (printf "%s" bits)
				    (let ((i 0)
					  (c 0))
				      (printf "\"")
				      (while (set c (char-at bits i))
					(if (and (<= 32 c) (<= c 126))
					    (cond
					      ((= c ?\")	(printf "\\\""))
					      ((= c ?\\)	(printf "\\\\"))
					      (else		(printf "%c" c)))
					  (printf "\\%03o" c))
					(set i (+ 1 i)))
				      (printf "\"")))))
      ((= type <symbol>)	(printf "%s" (get <symbol> _bits obj)))
      ((= type <pair>)		(let ()
				  (printf "(")
				  (while (and (is <pair> obj)) ;; (not (= globals obj))
				    (do_print (get_head obj) storing)
				    (and (is <pair> (set obj (get_tail obj))) (printf " ")))
				  ;; (and (= globals obj) (printf "<globals>"))
				  (and obj
				       (let ()
					 (printf " . ")
					 (do_print obj storing)))
				  (printf ")")))
      ((= type <array>)		(let ((len (k_array_length obj)))
				  (printf "Array(")
				  (for (i 0 len)
				    (and i (printf " "))
				    (do_print (k_array_at obj i)))
				  (printf ")")))
      (else			(printf "<type:%d>" type)))))

(define-function k_print (obj)		(do_print obj 1))

(define-function k_println (obj)	(k_print obj) (printf "\n"))

;;; ----------------------------------------------------------------

(define-function k_assq (key list)
  (while (is <pair> list)
    (let ((head (get_head list)))
      (and (is <pair> head)
	   (= key (get_head head))
	   (return head)))
    (set list (get_tail list))))

(define-function k_car (key list)	(and (is <pair> list) (get_head list)))
(define-function k_cdr (key list)	(and (is <pair> list) (get_tail list)))

(define-function k_caar (key list)
  (fatal "CAAR"))

(define-function k_array_length (obj)
  (and (is <array> obj)
       (let ((_arr (get <array> _array obj)))
	 (let ((sz (/ (gc_size _arr) 4)))
	   sz))))

(define-function k_array_at (obj idx)
  (and (is <array> obj)
       (let* ((elts (get <array> _array obj))
	      (size (gc_size elts)))
	 (and (<= 0 idx) (< idx size)
	      (oop-at elts idx)))))

(define-function k_concat (alist blist)
  (fatal "CONCAT"))

(define-function k_apply (key list)
  (fatal "APPLY"))

;;; ----------------------------------------------------------------

(define-function exlist (list env)
  (if (is <pair> list)
      (let ((head (expand (get_head list) env)))
	(gc-protect (head)
	  (let ((tail (exlist (get_tail list) env)))
	    (gc-protect (tail)
	      (new-<pair> head tail)))))
    list))

(define-function expand (exp env)
  (if (is <pair> exp)
      (let ((head (expand (get_head exp) env)))
	(gc_push_root (address-of head) "head")
	(if (is <symbol> head)
	    (let ((val (k_cdr (k_assq head env))))
	      (if (is <form> val)
		  (let ()
		    (set head (k_apply (get <form> function val) (get_tail exp) env))
		    (set head (expand head env))
		    (gc_pop_root (address-of head) "head")
		    (return head)))))
	(let ((tail (get_tail exp)))
	  (gc_push_root (address-of tail) "tail")
	  (or (= head s_quote) (set tail (exlist tail env)))
	  (and (= s_set head)
	       (is <pair>   (k_car  tail))
	       (is <symbol> (k_caar tail))
	       (let ((buf (new_buffer)))
		 (buffer_append_all buf "set-")
		 (buffer_append_all buf (get <symbol> _bits (get_head tail)))
		 (set head (intern (buffer_contents buf)))
		 (set tail (k_concat (get_tail (get_head tail)) (get_tail tail)))))
	  (set exp (new-<pair> head tail))
	  (gc_pop_root (address-of tail) "tail")
	  (gc_pop_root (address-of head) "head")))
    (let ((fn (k_array_at (get_tail expanders) (get-type exp))))
      (and fn
	   (let ((args (new-<pair> exp ())))
	     (gc-protect (args)
	       (set exp (k_apply fn args env)))))))
  exp)

;;; ----------------------------------------------------------------

(define-function repl_stream (stream)
  (let ((res 0))
    (fscanf stream "#!%*[^\012\015]")
    (while (!= EOF (set res (k_read stream)))
      (gc-protect (res)
	(printf "===>>> ") (k_println res)
	(set res (expand res globals))
	;(set obj (encode obj globals))
	;(set obj (eval   obj globals))
	(k_println res)))))

(define-function main (argc argv)
  (set stdin  (fdopen 0 "r"))
  (set stdout (fdopen 1 "a"))
  (set stderr (fdopen 2 "a"))
  (gc_initialise)
  (gc_push_root (address-of symbols) "symbols")
  (gc_push_root (address-of globals) "globals")
  (set s_set			(intern "set"))
  (set s_quote			(intern "quote"))
  (set s_quasiquote		(intern "quasiquote"))
  (set s_unquote		(intern "unquote"))
  (set s_unquote_splicing	(intern "unquote-splicing"))
  (set s_expanders		(intern "*expanders*"))
  (gc_push_root (address-of expanders))		(set expanders (new-<array> 0))		(set expanders (new-<pair> s_expanders expanders))
  (k_println (new-<array> 3))
  (while (set argc (- argc 1))
    (set argv (+ argv 4))
    (let ((stream (fopen (oop-at argv 0) "r")))
      (or stream (fatal1 "no such file: %s" (oop-at argv 0)))
      (repl_stream stream)
      (fclose stream)))
  ;;(gc_gcollect)
  0)

(compile-end)
