; defining bootstrap parser
; parsing peg grammar definition
; generating compiled parser
; compiling generated parser
; reparsing grammar definition
; comparing output
; dumping generated parser
(define-class <peg> <parser> ())
(define-selector $effect)
(define-selector $value)
(define-selector $findvars)
(define-selector $gen_cola_effect_definition)
(define-selector $gen_cola_effect_definitions)
(define-selector $gen_cola_effect_declaration)
(define-selector $gen_cola_effect_declarations)
(define-selector $gen_cola_value_definition)
(define-selector $gen_cola_value_definitions)
(define-selector $gen_cola_value_declaration)
(define-selector $gen_cola_value_declarations)
(define-selector $gen_cola)
(define-selector $start)
(define-selector $definition)
(define-selector $expression)
(define-selector $sequence)
(define-selector $predicate)
(define-selector $conversion)
(define-selector $repetition)
(define-selector $atom)
(define-selector $llist)
(define-selector $sexpression)
(define-selector $sspace)
(define-selector $scomment)
(define-selector $sexpr)
(define-selector $symbol)
(define-selector $symrest)
(define-selector $symfirst)
(define-selector $grammar)
(define-selector $class)
(define-selector $string)
(define-selector $char)
(define-selector $identifier)
(define-selector $idpart)
(define-selector $letter)
(define-selector $digit)
(define-selector $dot)
(define-selector $rbrace)
(define-selector $lbrace)
(define-selector $rparen)
(define-selector $lparen)
(define-selector $star)
(define-selector $plus)
(define-selector $minus)
(define-selector $query)
(define-selector $at)
(define-selector $dollar)
(define-selector $dollardbl)
(define-selector $dollarhash)
(define-selector $comma)
(define-selector $commaat)
(define-selector $backquote)
(define-selector $quotesgl)
(define-selector $arrow)
(define-selector $colon)
(define-selector $ampersand)
(define-selector $pling)
(define-selector $bar)
(define-selector $space)
(define-selector $comment)
(define-selector $eol)
(define-selector $blank)
(define-selector $equals)
(define-method $effect <peg> () (let ((op) (obj) (str) (exp) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set args self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (quote ()) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $$) name) (cons (quote self) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (let () (set self.result (cons (concat-symbol (quote $$) name) (cons (quote self) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set type self.result) (quote t))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set args self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote let) (cons (quote ()) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $$) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set type self.result) (quote t))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (let () (set self.result (cons (concat-symbol (quote $$) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-first) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set exps self.result) (quote t))) (let () (set self.result (cons (quote or) exps)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-all) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (let ((_list_ (group))) (while ($effect self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote or) (cons (cons (quote and) e) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-zero-one) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (quote ()) (cons exp (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-zero-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote while) (cons exp (quote ()))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-one-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote while) (cons exp (quote ()))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote peek-for) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote peek-not) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote not) (cons (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ())))) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-list) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons (cons (quote pair?) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (cons (cons (quote src) (cons (quote self.source) (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (cons (quote parser-stream) (cons (cons (quote list-stream) (cons (cons (quote parser-stream-peek) (cons (quote src) (quote ()))) (quote ()))) (quote ()))) (quote ())))) (cons (cons (quote let) (cons (cons (cons (quote ok) (cons exp (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (quote src) (quote ())))) (cons (cons (quote and) (cons (quote ok) (cons (cons (quote parser-stream-next) (cons (quote src) (quote ()))) (quote ())))) (quote ()))))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-class) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set str self.result) (quote t))) (let () (set self.result (cons (quote parser-stream-match-class) (cons (quote self.source) (cons str (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set str self.result) (quote t))) (let () (set self.result (cons (quote parser-stream-match-string) (cons (quote self.source) (cons str (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-object) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set obj self.result) (quote t))) (let () (set self.result (cons (quote parser-stream-match-object) (cons (quote self.source) (cons (cons (quote quote) (cons obj (quote ()))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-any) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let () (set self.result (quote (parser-stream-match-any self.source))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-span) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result exp) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result exp) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-symbol) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result exp) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-number) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result exp) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons name (cons (quote self.result) (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (quote ()) (cons exp (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set op self.result) (quote t))) (let () (set self.result (error "cannot generate value for " op)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result (error "cannot generate value for nil")) (quote t))))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $value <peg> () (let ((op) (obj) (str) (exp) (v) (e) (exps) (type) (args) (name)) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set args self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (quote ()) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $) name) (cons (quote self) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (let () (set self.result (cons (concat-symbol (quote $) name) (cons (quote self) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set type self.result) (quote t))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and (let ((_list_ (group))) (while (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set args self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote let) (cons (quote ()) (concat-list (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args) (cons (cons (quote or) (cons (cons (concat-symbol (quote $) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-rule-in) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set type self.result) (quote t))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (let () (set self.result (cons (concat-symbol (quote $) name) (cons (cons (quote parser) (cons (concat-symbol (quote <) (concat-symbol type (quote >))) (cons (quote self.source) (quote ())))) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-first) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (let ((_list_ (group))) (while ($value self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set exps self.result) (quote t))) (let () (set self.result (cons (quote or) exps)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-all) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (let ((pos (oop-at self.source 1))) (and (let ((pos (oop-at self.source 1))) (or (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (set-oop-at self.source 1 pos))) ($effect self)) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set e self.result) (quote t))) (and ($value self) (let () (set v self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote or) (cons (cons (quote and) (concat-list e (cons v (quote ())))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (cons (quote ()) (quote ()))))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-zero-one) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-zero-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote while) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-one-more) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote _list_) (cons (cons (quote group) (quote ())) (quote ()))) (quote ())) (cons (cons (quote while) (cons exp (cons (cons (quote group-append) (cons (quote _list_) (cons (quote self.result) (quote ())))) (quote ())))) (cons (cons (quote and) (cons (cons (quote not) (cons (cons (quote group-empty?) (cons (quote _list_) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote group->list!) (cons (quote _list_) (quote ()))) (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote peek-for) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote peek-not) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote not) (cons (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote set) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (cons (quote pos) (quote ())))) (quote ())))) (quote ())))) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-list) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons (cons (quote pair?) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ()))) (cons (cons (quote let) (cons (cons (cons (quote src) (cons (quote self.source) (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (cons (quote parser-stream) (cons (cons (quote list-stream) (cons (cons (quote parser-stream-peek) (cons (quote src) (quote ()))) (quote ()))) (quote ()))) (quote ())))) (cons (cons (quote let) (cons (cons (cons (quote ok) (cons exp (quote ()))) (quote ())) (cons (cons (quote set) (cons (quote self.source) (cons (quote src) (quote ())))) (cons (cons (quote and) (cons (quote ok) (cons (cons (quote parser-stream-next) (cons (quote src) (quote ()))) (quote ())))) (quote ()))))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-class) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set str self.result) (quote t))) (let () (set self.result (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-match-class) (cons (quote self.source) (cons str (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set str self.result) (quote t))) (let () (set self.result (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-match-string) (cons (quote self.source) (cons str (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-object) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set obj self.result) (quote t))) (let () (set self.result (cons (quote and) (cons (cons (quote =) (cons (cons (quote quote) (cons obj (quote ()))) (cons (cons (quote parser-stream-peek) (cons (quote self.source) (quote ()))) (quote ())))) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote parser-stream-next) (cons (quote self.source) (quote ()))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote match-any) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let () (set self.result (quote (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-span) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($effect self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (cons (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ()))) (quote ())) (cons (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote list-from-to) (cons (quote pos) (cons (cons (quote <parser-stream>-position) (cons (quote self.source) (quote ()))) (quote ())))) (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-string) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-symbol) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote string->symbol) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ()))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote make-number) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote set) (cons (quote self.result) (cons (cons (quote string->number) (cons (cons (quote list->string) (cons (quote self.result) (quote ()))) (quote ()))) (quote ())))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and ($value self) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote and) (cons exp (cons (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons name (cons (quote self.result) (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ()))))) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set exp self.result) (quote t))) (let () (set self.result (cons (quote let) (cons (quote ()) (cons (cons (quote set) (cons (quote self.result) (cons exp (quote ())))) (cons (cons (quote quote) (cons (quote t) (quote ()))) (quote ())))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set op self.result) (quote t))) (let () (set self.result (error "cannot generate value for " op)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result (error "cannot generate value for nil")) (quote t))))) (set self.source src) (and ok (parser-stream-next src)))))))
(define-method $findvars <peg> () (let ((name) (vars)) (let ((pos (oop-at self.source 1))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set vars self.result) (quote t))) (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (or (let ((pos (oop-at self.source 1))) (or (and (and (= (quote assign-result) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set name self.result) (quote t))) (and (let ((pos (oop-at self.source 1))) (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set-oop-at self.source 1 pos) ())))) (let () (set vars self.result) (quote t))) (let () (set self.result (if (assq name vars) vars (cons (cons name) vars))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (= (quote result-expr) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source))) (let () (set self.result vars) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let ((_list_ (group))) (while (and (let ((pos (oop-at self.source 1))) (let () (parser-stream-push self.source vars) (or ($findvars self) (let () (set-oop-at self.source 1 pos) ())))) (let () (set vars self.result) (quote t))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set self.result vars) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result vars) (quote t))))) (set self.source src) (and ok (parser-stream-next src)))))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $gen_cola_effect_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (oop-at self.source 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (oop-at self.source 1))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set id self.result) (quote t))) (let ((pos (oop-at self.source 1))) (and (and (let ((pos (oop-at self.source 1))) (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set-oop-at self.source 1 pos) ())))) (let () (set vars self.result) (quote t))) (set-oop-at self.source 1 pos))) (and ($effect self) (let () (set exp self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (cons (quote define-method) (cons (concat-symbol (quote $$) id) (cons (quote <peg>) (cons (quote ()) (cons (cons (quote let) (cons vars (cons exp (quote ())))) (quote ()))))))) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $gen_cola_effect_definitions <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_effect_definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))))
(define-method $gen_cola_effect_declaration <peg> () (let ((id)) (let ((pos (oop-at self.source 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set id self.result) (quote t))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (cons (quote define-selector) (cons (concat-symbol (quote $$) id) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $gen_cola_effect_declarations <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_effect_declaration self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))))
(define-method $gen_cola_value_definition <peg> () (let ((exp) (vars) (id)) (let ((pos (oop-at self.source 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (let ((pos (oop-at self.source 1))) (or (and (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set id self.result) (quote t))) (let ((pos (oop-at self.source 1))) (and (and (let ((pos (oop-at self.source 1))) (let () (parser-stream-push self.source ()) (or ($findvars self) (let () (set-oop-at self.source 1 pos) ())))) (let () (set vars self.result) (quote t))) (set-oop-at self.source 1 pos))) (and ($value self) (let () (set exp self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (cons (quote define-method) (cons (concat-symbol (quote $) id) (cons (quote <peg>) (cons (quote ()) (cons (cons (quote let) (cons vars (cons exp (quote ())))) (quote ()))))))) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $gen_cola_value_definitions <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_value_definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))))
(define-method $gen_cola_value_declaration <peg> () (let ((id)) (let ((pos (oop-at self.source 1))) (or (and (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (and (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))) (let () (set id self.result) (quote t))))) (set self.source src) (and ok (parser-stream-next src))))) (let () (set self.result (cons (quote define-selector) (cons (concat-symbol (quote $) id) (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $gen_cola_value_declarations <peg> () (let () (let ((_list_ (group))) (while ($gen_cola_value_declaration self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))))
(define-method $gen_cola <peg> () (let ((d) (c) (b) (a)) (let ((pos (oop-at self.source 1))) (or (and (let ((pos (oop-at self.source 1))) (and (and ($gen_cola_value_declarations self) (let () (set a self.result) (quote t))) (set-oop-at self.source 1 pos))) (let ((pos (oop-at self.source 1))) (and (and ($gen_cola_effect_declarations self) (let () (set b self.result) (quote t))) (set-oop-at self.source 1 pos))) (let ((pos (oop-at self.source 1))) (and (and ($gen_cola_value_definitions self) (let () (set c self.result) (quote t))) (set-oop-at self.source 1 pos))) (and ($gen_cola_effect_definitions self) (let () (set d self.result) (quote t))) (let () (set self.result (concat-list a (concat-list b (concat-list c d)))) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $start <peg> () (let () ($definition self)))
(define-method $definition <peg> () (let ((e) (id)) (let ((pos (oop-at self.source 1))) (or (and ($space self) (and ($identifier self) (let () (set id self.result) (quote t))) ($equals self) (and ($expression self) (let () (set e self.result) (quote t))) (set self.result (parser-stream-match-string self.source ";")) (let () (set self.result (cons id (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $expression <peg> () (let ((t) (s)) (let ((pos (oop-at self.source 1))) (or (and (and ($sequence self) (let () (set s self.result) (quote t))) (or (let ((pos (oop-at self.source 1))) (or (and (and (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and ($bar self) ($sequence self)) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set t self.result) (quote t))) (let () (set self.result (cons (quote match-first) (cons s t))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result s) (quote t)))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $sequence <peg> () (let ((q) (p)) (let ((pos (oop-at self.source 1))) (or (and (and ($predicate self) (let () (set p self.result) (quote t))) (or (let ((pos (oop-at self.source 1))) (or (and (and (let ((_list_ (group))) (while ($predicate self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (let () (set q self.result) (quote t))) (let () (set self.result (cons (quote match-all) (cons p q))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result p) (quote t)))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $predicate <peg> () (let ((e)) (or (let ((pos (oop-at self.source 1))) (or (and ($pling self) (and ($conversion self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote peek-not) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($ampersand self) (and ($conversion self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote peek-for) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) ($conversion self))))
(define-method $conversion <peg> () (let ((i) (e)) (let ((pos (oop-at self.source 1))) (or (and (and ($repetition self) (let () (set e self.result) (quote t))) (let ((_list_ (group))) (while (or (let ((pos (oop-at self.source 1))) (or (and ($at self) (and (let () (set self.result (cons (quote make-span) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($dollarhash self) (and (let () (set self.result (cons (quote make-number) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($dollardbl self) (and (let () (set self.result (cons (quote make-symbol) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($dollar self) (and (let () (set self.result (cons (quote make-string) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($colon self) (and ($identifier self) (let () (set i self.result) (quote t))) (and (let () (set self.result (cons (quote assign-result) (cons i (cons e (quote ()))))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ())))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $repetition <peg> () (let ((e)) (let ((pos (oop-at self.source 1))) (or (and (and ($atom self) (let () (set e self.result) (quote t))) (let ((_list_ (group))) (and (or (let ((pos (oop-at self.source 1))) (or (and ($query self) (and (let () (set self.result (cons (quote match-zero-one) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($star self) (and (let () (set self.result (cons (quote match-zero-more) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($plus self) (and (let () (set self.result (cons (quote match-one-more) (cons e (quote ())))) (quote t)) (let () (set e self.result) (quote t)))) (let () (set-oop-at self.source 1 pos) ())))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $atom <peg> () (let ((p) (e)) (or (let ((pos (oop-at self.source 1))) (or (and ($lparen self) (and ($expression self) (let () (set e self.result) (quote t))) ($rparen self) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($quotesgl self) (and ($sexpression self) (let () (set e self.result) (quote t))) ($space self) (let () (set self.result (cons (quote match-object) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and ($string self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote match-string) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and ($class self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote match-class) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and ($idpart self) (let () (set p self.result) (quote t))) (set self.result (parser-stream-match-string self.source "-")) (and ($identifier self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote match-rule-in) (cons p (cons e (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and ($identifier self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote match-rule) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($lbrace self) (and (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set e self.result) (quote t))) ($space self) ($rbrace self) (let () (set self.result (cons (quote match-rule) e)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($dot self) (let () (set self.result (cons (quote match-any) (quote ()))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($arrow self) (and ($sexpression self) (let () (set e self.result) (quote t))) ($space self) (let () (set self.result (cons (quote result-expr) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and ($backquote self) (and ($llist self) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote match-list) (cons e (quote ())))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))))))
(define-method $llist <peg> () (let ((e)) (let ((pos (oop-at self.source 1))) (or (and ($lparen self) (and ($expression self) (let () (set e self.result) (quote t))) ($rparen self) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $sexpression <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and ($sspace self) ($sexpr self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $sspace <peg> () (let () (let ((_list_ (group))) (while (or ($blank self) ($eol self) ($scomment self)) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))))
(define-method $scomment <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ";")) (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (not (let ((pos (oop-at self.source 1))) (and ($eol self) (set-oop-at self.source 1 pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $sexpr <peg> () (let ((e)) (or ($symbol self) (and (let ((_list_ (group))) (while ($digit self) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) (quote t)))) (set self.result (string->number (list->string self.result)))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "\"")) (and (and (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (not (let ((pos (oop-at self.source 1))) (and (set self.result (parser-stream-match-string self.source "\"")) (set-oop-at self.source 1 pos)))) ($char self)) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (set self.result (list->string self.result))) (let () (set e self.result) (quote t))) (set self.result (parser-stream-match-string self.source "\"")) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "(")) (and (let ((_list_ (group))) (while ($sexpression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set e self.result) (quote t))) ($sspace self) (set self.result (parser-stream-match-string self.source ")")) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "'")) (and ($sexpression self) (let () (set e self.result) (quote t))) (let () (set self.result (list (quote quote) e)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "`")) (and ($sexpression self) (let () (set e self.result) (quote t))) (let () (set self.result (list (quote quasiquote) e)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ",@")) (and ($sexpression self) (let () (set e self.result) (quote t))) (let () (set self.result (list (quote unquote-splicing) e)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ",")) (and ($sexpression self) (let () (set e self.result) (quote t))) (let () (set self.result (list (quote unquote) e)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "{")) ($space self) (and ($grammar self) (let () (set e self.result) (quote t))) (set self.result (parser-stream-match-string self.source "}")) (let () (set self.result e) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ";")) (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (not (let ((pos (oop-at self.source 1))) (and (set self.result (parser-stream-match-class self.source "\012\015")) (set-oop-at self.source 1 pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))))))
(define-method $symbol <peg> () (let () (and (let ((pos (oop-at self.source 1))) (and (let ((pos (oop-at self.source 1))) (or (and ($symfirst self) (let ((_list_ (group))) (while ($symrest self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at self.source 1))) (quote t)))) (set self.result (string->symbol (list->string self.result))))))
(define-method $symrest <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-./0123456789<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $symfirst <peg> () (let () (set self.result (parser-stream-match-class self.source "!#$%&*+-./<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz|~"))))
(define-method $grammar <peg> () (let ((e) (d) (parent) (rules) (name)) (or (let ((pos (oop-at self.source 1))) (or (and (and ($symbol self) (let () (set name self.result) (quote t))) ($space self) ($plus self) (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set rules self.result) (quote t))) (let () (set self.result (cons (quote grammar-extend) (cons name rules))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and ($symbol self) (let () (set name self.result) (quote t))) ($space self) ($colon self) (and ($symbol self) (let () (set parent self.result) (quote t))) (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set rules self.result) (quote t))) (let () (set self.result (cons (quote grammar-define) (cons name (cons parent rules)))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (and (let ((_list_ (group))) (while ($definition self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set d self.result) (quote t))) ($space self) (and (let ((_list_ (group))) (and ($expression self) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (let () (set e self.result) (quote t))) (let () (set self.result (cons (quote grammar-eval) (cons d (cons (car e) (quote ()))))) (quote t))) (let () (set-oop-at self.source 1 pos) ()))))))
(define-method $class <peg> () (let ((s)) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "[")) (and (and (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (not (let ((pos (oop-at self.source 1))) (and (set self.result (parser-stream-match-string self.source "]")) (set-oop-at self.source 1 pos)))) ($char self)) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (set self.result (list->string self.result))) (let () (set s self.result) (quote t))) (set self.result (parser-stream-match-string self.source "]")) ($space self) (let () (set self.result s) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $string <peg> () (let ((s)) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "\"")) (and (and (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (not (let ((pos (oop-at self.source 1))) (and (set self.result (parser-stream-match-string self.source "\"")) (set-oop-at self.source 1 pos)))) ($char self)) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t)) (set self.result (list->string self.result))) (let () (set s self.result) (quote t))) (set self.result (parser-stream-match-string self.source "\"")) ($space self) (let () (set self.result s) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $char <peg> () (let () (or (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "\\")) (or (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "t")) (let () (set self.result 9) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "n")) (let () (set self.result 10) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "r")) (let () (set self.result 13) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))))) (let () (set-oop-at self.source 1 pos) ()))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t))))))
(define-method $identifier <peg> () (let ((id)) (let ((pos (oop-at self.source 1))) (or (and (and ($idpart self) (let () (set id self.result) (quote t))) ($space self) (let () (set self.result id) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $idpart <peg> () (let () (and (let ((pos (oop-at self.source 1))) (and (let ((pos (oop-at self.source 1))) (or (and ($letter self) (let ((_list_ (group))) (while (or ($letter self) ($digit self)) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let () (set self.result (list-from-to pos (oop-at self.source 1))) (quote t)))) (set self.result (string->symbol (list->string self.result))))))
(define-method $letter <peg> () (let () (set self.result (parser-stream-match-class self.source "ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"))))
(define-method $digit <peg> () (let () (set self.result (parser-stream-match-class self.source "0123456789"))))
(define-method $dot <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ".")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $rbrace <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "}")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $lbrace <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "{")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $rparen <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ")")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $lparen <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "(")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $star <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "*")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $plus <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "+")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $minus <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "-")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $query <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "?")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $at <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "@")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $dollar <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "$")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $dollardbl <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "$$")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $dollarhash <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "$#")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $comma <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ",")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $commaat <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ",@")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $backquote <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "`")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $quotesgl <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "'")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $arrow <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "->")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $colon <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source ":")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $ampersand <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "&")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $pling <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "!")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $bar <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "|")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $space <peg> () (let () (let ((_list_ (group))) (while (or ($blank self) ($eol self) ($comment self)) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))))
(define-method $comment <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "#")) (let ((_list_ (group))) (while (let ((pos (oop-at self.source 1))) (or (and (not (let ((pos (oop-at self.source 1))) (and ($eol self) (set-oop-at self.source 1 pos)))) (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) (quote t)))) (let () (set-oop-at self.source 1 pos) ()))) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ())))))
(define-method $eol <peg> () (let () (or (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "\012")) (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\015")) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))) (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "\015")) (let ((_list_ (group))) (while (set self.result (parser-stream-match-string self.source "\012")) (group-append _list_ self.result)) (set self.result (group->list! _list_)) (quote t))) (let () (set-oop-at self.source 1 pos) ()))))))
(define-method $blank <peg> () (let () (set self.result (parser-stream-match-class self.source "\011 "))))
(define-method $equals <peg> () (let () (let ((pos (oop-at self.source 1))) (or (and (set self.result (parser-stream-match-string self.source "=")) ($space self)) (let () (set-oop-at self.source 1 pos) ())))))
; parser bootstrap complete
; WARNING: unreachable from start: commaat
; WARNING: unreachable from start: comma
; WARNING: unreachable from start: minus
; WARNING: unreachable from start: gen_cola
; WARNING: unreachable from start: gen_cola_value_declarations
; WARNING: unreachable from start: gen_cola_value_declaration
; WARNING: unreachable from start: gen_cola_value_definitions
; WARNING: unreachable from start: gen_cola_value_definition
; WARNING: unreachable from start: gen_cola_effect_declarations
; WARNING: unreachable from start: gen_cola_effect_declaration
; WARNING: unreachable from start: gen_cola_effect_definitions
; WARNING: unreachable from start: gen_cola_effect_definition
; WARNING: unreachable from start: findvars
; WARNING: unreachable from start: value
; WARNING: unreachable from start: effect
