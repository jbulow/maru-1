; defining bootstrap parser
; parsing peg grammar definition
; generating compiled parser
; compiling generated parser
; reparsing grammar definition
; comparing output
; dumping generated parser
(define-class <peg> <parser> (grammar-name))
(define-selector $effect)
(define-selector $value)
(define-selector $findvars)
(define-selector $gen_cola_effect_definition)
(define-selector $gen_cola_value_definition)
(define-selector $gen_cola_effect_definitions)
(define-selector $gen_cola_value_definitions)
(define-selector $gen_cola_effect_declaration)
(define-selector $gen_cola_value_declaration)
(define-selector $gen_cola_effect_declarations)
(define-selector $gen_cola_value_declarations)
(define-selector $gen_cola)
(define-selector $gen_cola_parser)
(define-selector $parser_spec)
(define-selector $varname)
(define-selector $start)
(define-selector $definition)
(define-selector $expression)
(define-selector $sequence)
(define-selector $predicate)
(define-selector $conversion)
(define-selector $repetition)
(define-selector $atom)
(define-selector $llist)
(define-selector $sexpression)
(define-selector $sspace)
(define-selector $scomment)
(define-selector $sexpr)
(define-selector $symbol)
(define-selector $symrest)
(define-selector $symfirst)
(define-selector $grammar)
(define-selector $class)
(define-selector $string)
(define-selector $char)
(define-selector $identifier)
(define-selector $idpart)
(define-selector $letter)
(define-selector $number)
(define-selector $higit)
(define-selector $digit)
(define-selector $dot)
(define-selector $rbrace)
(define-selector $lbrace)
(define-selector $rparen)
(define-selector $lparen)
(define-selector $star)
(define-selector $plus)
(define-selector $minus)
(define-selector $query)
(define-selector $at)
(define-selector $dollar)
(define-selector $dollardbl)
(define-selector $dollarhash)
(define-selector $comma)
(define-selector $commaat)
(define-selector $backquote)
(define-selector $quotesgl)
(define-selector $arrow)
(define-selector $colon)
(define-selector $ampersand)
(define-selector $pling)
(define-selector $bar)
(define-selector $space)
(define-selector $comment)
(define-selector $eol)
(define-selector $blank)
(define-selector $equals)
(define-method $effect <peg> () (let ((op) (r) (obj) (str) (exp) (e) (exps) (type) (args) (name)) (match-list (match-first (match-all (match-object match-rule) (assign-result name (match-any)) (assign-result args (match-one-more (match-any))) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or (peg-match-rule (unquote (concat-symbol (quote $$) name)) self) (let () (set (<parser-stream>-position self.source) pos) ())))))) (match-all (match-object match-rule) (assign-result name (match-any)) (result-expr (quasiquote (peg-match-rule (unquote (concat-symbol (quote $$) name)) self)))) (match-all (match-object match-rule-in) (assign-result type (match-any)) (assign-result name (match-any)) (assign-result args (match-one-more (match-any))) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (let () (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or (peg-match-rule (unquote (concat-symbol (quote $$) name)) (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source)) (let () (set (<parser-stream>-position self.source) pos) ()))))))) (match-all (match-object match-rule-in) (assign-result type (match-any)) (assign-result name (match-any)) (result-expr (quasiquote (peg-match-rule (unquote (concat-symbol (quote $$) name)) (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))))) (match-all (match-object match-first) (assign-result exps (match-one-more (match-rule effect))) (result-expr (quasiquote (or (unquote-splicing exps))))) (match-all (match-object match-all) (assign-result e (match-zero-more (match-rule effect))) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (or (and (unquote-splicing e)) (let () (set (<parser-stream>-position self.source) pos) ())))))) (match-all (match-object match-zero-one) (assign-result exp (match-rule effect)) (result-expr (quasiquote (let () (unquote exp) 1)))) (match-all (match-object match-zero-more) (assign-result exp (match-rule effect)) (result-expr (quasiquote (let () (while (unquote exp)) 1)))) (match-all (match-object match-one-more) (assign-result exp (match-rule effect)) (result-expr (quasiquote (and (unquote exp) (let () (while (unquote exp)) 1))))) (match-all (match-object peek-for) (assign-result exp (match-rule effect)) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos)))))) (match-all (match-object peek-expr) (assign-result exp (match-any)) (result-expr exp)) (match-all (match-object peek-not) (assign-result exp (match-rule effect)) (result-expr (quasiquote (not (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos))))))) (match-all (match-object match-list) (assign-result exp (match-rule effect)) (result-expr (quasiquote (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (unquote exp))) (set self.source src) (and ok (parser-stream-next src)))))))) (match-all (match-object match-class) (assign-result str (match-any)) (result-expr (quasiquote (parser-stream-match-class self.source (unquote (make-class str)))))) (match-all (match-object match-string) (assign-result str (match-any)) (result-expr (quasiquote (parser-stream-match-string self.source (unquote str))))) (match-all (match-object match-object) (assign-result obj (match-any)) (result-expr (quasiquote (parser-stream-match-object self.source (quote (unquote obj)))))) (match-all (match-object match-any) (result-expr (quote (parser-stream-match-any self.source)))) (match-all (match-object make-span) (assign-result exp (match-rule effect)) (result-expr exp)) (match-all (match-object make-string) (assign-result exp (match-rule effect)) (result-expr exp)) (match-all (match-object make-symbol) (assign-result exp (match-rule effect)) (result-expr exp)) (match-all (match-object make-number) (assign-result r (match-any)) (assign-result exp (match-rule effect)) (result-expr exp)) (match-all (match-object assign-result) (assign-result name (match-any)) (assign-result exp (match-rule value)) (result-expr (quasiquote (and (unquote exp) (let () (set (unquote name) self.result) 1))))) (match-all (match-object result-expr) (assign-result exp (match-any)) (result-expr (quasiquote (let () (unquote exp) 1)))) (match-all (assign-result op (match-any)) (result-expr (error "cannot generate value for " op))) (result-expr (error "cannot generate value for nil"))))))
(define-method $value <peg> () (let ((op) (r) (obj) (str) (exp) (v) (e) (exps) (type) (args) (name)) (match-list (match-first (match-all (match-object match-rule) (assign-result name (match-any)) (assign-result args (match-one-more (match-any))) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (or (peg-match-rule (unquote (concat-symbol (quote $) name)) self) (let () (set (<parser-stream>-position self.source) pos) ())))))) (match-all (match-object match-rule) (assign-result name (match-any)) (result-expr (quasiquote (peg-match-rule (unquote (concat-symbol (quote $) name)) self)))) (match-all (match-object match-rule-in) (assign-result type (match-any)) (assign-result name (match-any)) (assign-result args (match-one-more (match-any))) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source)) (_p (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) (unquote-splicing (map (lambda (arg) (list (quote parser-stream-push) (quote self.source) arg)) args)) (if (peg-match-rule (unquote (concat-symbol (quote $) name)) _p) (let () (set self.result (<parser>-result _p)) 1) (let () (set (<parser-stream>-position self.source) pos) ())))))) (match-all (match-object match-rule-in) (assign-result type (match-any)) (assign-result name (match-any)) (result-expr (quasiquote (let ((_p (parser (unquote (concat-symbol (quote <) (concat-symbol type (quote >)))) self.source))) (and (peg-match-rule (unquote (concat-symbol (quote $) name)) _p) (let () (set self.result (<parser>-result _p)) 1)))))) (match-all (match-object match-first) (assign-result exps (match-one-more (match-rule value))) (result-expr (quasiquote (or (unquote-splicing exps))))) (match-all (match-object match-all) (assign-result e (match-zero-more (match-all (peek-for (match-all (match-any) (match-any))) (match-rule effect)))) (assign-result v (match-rule value)) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (or (and (unquote-splicing e) (unquote v)) (let () (set (<parser-stream>-position self.source) pos) ())))))) (match-all (match-object match-zero-one) (assign-result exp (match-rule value)) (result-expr (quasiquote (let ((_list_ (group))) (and (unquote exp) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))) (match-all (match-object match-zero-more) (assign-result exp (match-rule value)) (result-expr (quasiquote (let ((_list_ (group))) (while (unquote exp) (group-append _list_ self.result)) (set self.result (group->list! _list_)) 1)))) (match-all (match-object match-one-more) (assign-result exp (match-rule value)) (result-expr (quasiquote (let ((_list_ (group))) (while (unquote exp) (group-append _list_ self.result)) (and (not (group-empty? _list_)) (let () (set self.result (group->list! _list_)) 1)))))) (match-all (match-object peek-for) (assign-result exp (match-rule value)) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos)))))) (match-all (match-object peek-expr) (assign-result exp (match-any)) (result-expr exp)) (match-all (match-object peek-not) (assign-result exp (match-rule value)) (result-expr (quasiquote (not (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (set (<parser-stream>-position self.source) pos))))))) (match-all (match-object match-list) (assign-result exp (match-rule value)) (result-expr (quasiquote (and (pair? (parser-stream-peek self.source)) (let ((src self.source)) (set self.source (parser-stream (list-stream (parser-stream-peek src)))) (let ((ok (unquote exp))) (set self.source src) (and ok (parser-stream-next src)))))))) (match-all (match-object match-class) (assign-result str (match-any)) (result-expr (quasiquote (set self.result (parser-stream-match-class self.source (unquote (make-class str))))))) (match-all (match-object match-string) (assign-result str (match-any)) (result-expr (quasiquote (set self.result (parser-stream-match-string self.source (unquote str)))))) (match-all (match-object match-object) (assign-result obj (match-any)) (result-expr (quasiquote (and (= (quote (unquote obj)) (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source)))))) (match-all (match-object match-any) (result-expr (quote (and (!= *end* (parser-stream-peek self.source)) (let () (set self.result (parser-stream-next self.source)) 1))))) (match-all (match-object make-span) (assign-result exp (match-rule effect)) (result-expr (quasiquote (let ((pos (<parser-stream>-position self.source))) (and (unquote exp) (let () (set self.result (list-from-to pos (<parser-stream>-position self.source))) 1)))))) (match-all (match-object make-string) (assign-result exp (match-rule value)) (result-expr (quasiquote (and (unquote exp) (set self.result (list->string self.result)))))) (match-all (match-object make-symbol) (assign-result exp (match-rule value)) (result-expr (quasiquote (and (unquote exp) (set self.result (string->symbol (list->string self.result))))))) (match-all (match-object make-number) (assign-result r (match-any)) (assign-result exp (match-rule value)) (result-expr (quasiquote (and (unquote exp) (set self.result (string->number-base (list->string self.result) (unquote r))))))) (match-all (match-object assign-result) (assign-result name (match-any)) (assign-result exp (match-rule value)) (result-expr (quasiquote (and (unquote exp) (let () (set (unquote name) self.result) 1))))) (match-all (match-object result-expr) (assign-result exp (match-any)) (result-expr (quasiquote (let () (set self.result (unquote exp)) 1)))) (match-all (assign-result op (match-any)) (result-expr (error "cannot generate value for " op))) (result-expr (error "cannot generate value for nil"))))))
(define-method $findvars <peg> () (let ((name) (vars)) (match-all (assign-result vars (match-any)) (match-list (match-first (match-all (match-object assign-result) (assign-result name (match-any)) (assign-result vars (match-rule findvars vars)) (result-expr (if (assq name vars) vars (cons (cons name) vars)))) (match-all (match-object result-expr) (result-expr vars)) (match-all (match-any) (match-zero-more (assign-result vars (match-rule findvars vars))) (result-expr vars)) (result-expr vars))))))
(define-method $gen_cola_effect_definition <peg> () (let ((exp) (vars) (id)) (match-all (match-list (match-all (assign-result id (match-any)) (peek-for (assign-result vars (match-rule findvars ()))) (assign-result exp (match-rule effect)))) (result-expr (quasiquote (peg-define-rule (unquote (concat-symbol (quote $$) id)) (unquote (<peg>-grammar-name self)) (unquote vars) (unquote exp)))))))
(define-method $gen_cola_value_definition <peg> () (let ((exp) (vars) (id)) (match-all (match-list (match-all (assign-result id (match-any)) (peek-for (assign-result vars (match-rule findvars ()))) (assign-result exp (match-rule value)))) (result-expr (quasiquote (peg-define-rule (unquote (concat-symbol (quote $) id)) (unquote (<peg>-grammar-name self)) (unquote vars) (unquote exp)))))))
(define-method $gen_cola_effect_definitions <peg> () (let ((d)) (match-all (match-list (assign-result d (match-zero-more (match-rule gen_cola_effect_definition)))) (result-expr d))))
(define-method $gen_cola_value_definitions <peg> () (let ((d)) (match-all (match-list (assign-result d (match-zero-more (match-rule gen_cola_value_definition)))) (result-expr d))))
(define-method $gen_cola_effect_declaration <peg> () (let ((id)) (match-all (match-list (assign-result id (match-any))) (result-expr (quasiquote (define-selector (unquote (concat-symbol (quote $$) id))))))))
(define-method $gen_cola_value_declaration <peg> () (let ((id)) (match-all (match-list (assign-result id (match-any))) (result-expr (quasiquote (define-selector (unquote (concat-symbol (quote $) id))))))))
(define-method $gen_cola_effect_declarations <peg> () (let ((d)) (match-all (match-list (assign-result d (match-zero-more (match-rule gen_cola_effect_declaration)))) (result-expr d))))
(define-method $gen_cola_value_declarations <peg> () (let ((d)) (match-all (match-list (assign-result d (match-zero-more (match-rule gen_cola_value_declaration)))) (result-expr d))))
(define-method $gen_cola <peg> () (let ((d) (c) (b) (a)) (match-all (peek-for (assign-result a (match-rule gen_cola_value_declarations))) (peek-for (assign-result b (match-rule gen_cola_effect_declarations))) (peek-for (assign-result c (match-rule gen_cola_value_definitions))) (assign-result d (match-rule gen_cola_effect_definitions)) (result-expr (quasiquote ((unquote-splicing a) (unquote-splicing b) (unquote-splicing c) (unquote-splicing d)))))))
(define-method $gen_cola_parser <peg> () (let ((definitions) (vars) (parent) (name)) (match-all (assign-result name (match-any)) (assign-result parent (match-any)) (assign-result vars (match-any)) (assign-result definitions (match-any)) (result-expr (set (<peg>-grammar-name self) name)) (assign-result definitions (match-rule gen_cola definitions)) (result-expr (quasiquote ((define-class (unquote name) (unquote parent) (unquote vars)) (unquote-splicing definitions)))))))
(define-method $parser_spec <peg> () (let ((definitions) (vars) (parent) (name)) (match-all (assign-result name (match-rule varname)) (match-rule colon) (assign-result parent (match-rule varname)) (match-rule lparen) (assign-result vars (match-zero-more (match-rule varname))) (match-rule rparen) (assign-result definitions (match-zero-more (match-rule definition))) (match-rule space) (match-first (peek-not (match-any)) (result-expr (error "error in grammar near: " (parser-stream-context self.source)))) (match-rule gen_cola_parser name parent vars definitions))))
(define-method $varname <peg> () (let ((s)) (match-all (assign-result s (match-rule symbol)) (match-rule space) (result-expr s))))
(define-method $start <peg> () (let ((result)) (match-all (match-rule space) (assign-result result (match-first (match-rule parser_spec) (match-zero-more (match-rule definition)))))))
(define-method $definition <peg> () (let ((e) (id)) (match-all (match-rule space) (assign-result id (match-rule identifier)) (match-rule equals) (assign-result e (match-rule expression)) (match-string ";") (result-expr (quasiquote ((unquote id) (unquote e)))))))
(define-method $expression <peg> () (let ((t) (s)) (match-all (assign-result s (match-rule sequence)) (match-first (match-all (assign-result t (match-one-more (match-all (match-rule bar) (match-rule sequence)))) (result-expr (quasiquote (match-first (unquote s) (unquote-splicing t))))) (result-expr s)))))
(define-method $sequence <peg> () (let ((q) (p)) (match-all (assign-result p (match-rule predicate)) (match-first (match-all (assign-result q (match-one-more (match-rule predicate))) (result-expr (quasiquote (match-all (unquote p) (unquote-splicing q))))) (result-expr p)))))
(define-method $predicate <peg> () (let ((e)) (match-first (match-all (match-rule pling) (assign-result e (match-rule conversion)) (result-expr (quasiquote (peek-not (unquote e))))) (match-all (match-rule ampersand) (match-first (match-all (match-rule arrow) (assign-result e (match-rule sexpression)) (match-rule space) (result-expr (quasiquote (peek-expr (unquote e))))) (match-all (assign-result e (match-rule conversion)) (result-expr (quasiquote (peek-for (unquote e))))))) (match-rule conversion))))
(define-method $conversion <peg> () (let ((i) (n) (e)) (match-all (assign-result e (match-rule repetition)) (match-zero-more (match-first (match-all (match-rule at) (assign-result e (result-expr (quasiquote (make-span (unquote e)))))) (match-all (match-rule dollarhash) (match-first (match-all (assign-result n (match-rule number)) (assign-result e (result-expr (quasiquote (make-number (unquote n) (unquote e)))))) (assign-result e (result-expr (quasiquote (make-number 10 (unquote e))))))) (match-all (match-rule dollardbl) (assign-result e (result-expr (quasiquote (make-symbol (unquote e)))))) (match-all (match-rule dollar) (assign-result e (result-expr (quasiquote (make-string (unquote e)))))) (match-all (match-rule colon) (assign-result i (match-rule identifier)) (assign-result e (result-expr (quasiquote (assign-result (unquote i) (unquote e)))))))) (result-expr e))))
(define-method $repetition <peg> () (let ((e)) (match-all (assign-result e (match-rule atom)) (match-zero-one (match-first (match-all (match-rule query) (assign-result e (result-expr (quasiquote (match-zero-one (unquote e)))))) (match-all (match-rule star) (assign-result e (result-expr (quasiquote (match-zero-more (unquote e)))))) (match-all (match-rule plus) (assign-result e (result-expr (quasiquote (match-one-more (unquote e)))))))) (result-expr e))))
(define-method $atom <peg> () (let ((p) (e)) (match-first (match-all (match-rule lparen) (assign-result e (match-rule expression)) (match-rule rparen) (result-expr e)) (match-all (match-rule quotesgl) (assign-result e (match-rule sexpression)) (match-rule space) (result-expr (quasiquote (match-object (unquote e))))) (match-all (assign-result e (match-rule string)) (result-expr (quasiquote (match-string (unquote e))))) (match-all (assign-result e (match-rule class)) (result-expr (quasiquote (match-class (unquote e))))) (match-all (assign-result p (match-rule idpart)) (match-string "-") (assign-result e (match-rule identifier)) (result-expr (quasiquote (match-rule-in (unquote p) (unquote e))))) (match-all (assign-result e (match-rule identifier)) (result-expr (quasiquote (match-rule (unquote e))))) (match-all (match-rule lbrace) (assign-result e (match-zero-more (match-rule sexpression))) (match-rule space) (match-rule rbrace) (result-expr (quasiquote (match-rule (unquote-splicing e))))) (match-all (match-rule dot) (result-expr (quasiquote (match-any)))) (match-all (match-rule arrow) (assign-result e (match-rule sexpression)) (match-rule space) (result-expr (quasiquote (result-expr (unquote e))))) (match-all (match-rule backquote) (assign-result e (match-rule llist)) (result-expr (quasiquote (match-list (unquote e))))))))
(define-method $llist <peg> () (let ((e)) (match-all (match-rule lparen) (assign-result e (match-rule expression)) (match-rule rparen) (result-expr e))))
(define-method $sexpression <peg> () (let () (match-all (match-rule sspace) (match-rule sexpr))))
(define-method $sspace <peg> () (let () (match-zero-more (match-first (match-rule blank) (match-rule eol) (match-rule scomment)))))
(define-method $scomment <peg> () (let () (match-all (match-string ";") (match-zero-more (match-all (peek-not (match-rule eol)) (match-any))))))
(define-method $sexpr <peg> () (let ((f) (e)) (match-first (make-number 10 (make-span (match-all (match-zero-one (match-string "-")) (match-one-more (match-rule digit))))) (match-rule symbol) (match-all (match-string "?") (match-any)) (match-all (match-string "\"") (assign-result e (make-string (match-zero-more (match-all (peek-not (match-string "\"")) (match-rule char))))) (match-string "\"") (result-expr e)) (match-all (match-string "(") (assign-result e (match-zero-more (match-rule sexpression))) (match-zero-one (match-all (match-rule space) (match-rule dot) (assign-result f (match-rule sexpression)))) (match-rule sspace) (match-string ")") (result-expr (set-list-source (quasiquote ((unquote-splicing e) (unquote-splicing f))) e))) (match-all (match-string "[") (assign-result e (match-zero-more (match-rule sexpression))) (match-zero-one (match-all (match-rule space) (match-rule dot) (assign-result f (match-rule sexpression)))) (match-rule sspace) (match-string "]") (result-expr (set-list-source (quasiquote (bracket (unquote-splicing e) (unquote-splicing f))) e))) (match-all (match-string "'") (assign-result e (match-rule sexpression)) (result-expr (list (quote quote) e))) (match-all (match-string "`") (assign-result e (match-rule sexpression)) (result-expr (list (quote quasiquote) e))) (match-all (match-string ",@") (assign-result e (match-rule sexpression)) (result-expr (list (quote unquote-splicing) e))) (match-all (match-string ",") (assign-result e (match-rule sexpression)) (result-expr (list (quote unquote) e))) (match-all (match-string "{") (match-rule space) (assign-result e (match-rule grammar)) (match-first (match-all (match-string "}") (result-expr e)) (result-expr (error "error in grammar near: " (parser-stream-context self.source))))) (match-all (match-string ";") (match-zero-more (match-all (peek-not (match-class "\012\015")) (match-any)))))))
(define-method $symbol <peg> () (let () (make-symbol (make-span (match-all (match-rule symfirst) (match-zero-more (match-rule symrest)))))))
(define-method $symrest <peg> () (let () (match-class "-!#$%&*+./:0-9<=>?@A-Z^_a-z|~")))
(define-method $symfirst <peg> () (let () (match-class "-!#$%&*+/:<=>@A-Z^_a-z|~")))
(define-method $grammar <peg> () (let ((e) (d) (fields) (parent) (rules) (name)) (match-first (match-all (assign-result name (match-rule symbol)) (match-rule space) (match-rule plus) (assign-result rules (match-zero-more (match-rule definition))) (match-rule space) (result-expr (quasiquote (grammar-extend (unquote name) (unquote-splicing rules))))) (match-all (assign-result name (match-rule symbol)) (match-rule space) (match-rule colon) (assign-result parent (match-rule symbol)) (match-rule space) (match-zero-one (match-all (match-rule lparen) (assign-result fields (match-zero-more (match-rule identifier))) (match-rule rparen))) (assign-result rules (match-zero-more (match-rule definition))) (match-rule space) (result-expr (quasiquote (grammar-define (unquote name) (unquote parent) (unquote fields) (unquote-splicing rules))))) (match-all (assign-result d (match-zero-more (match-rule definition))) (match-rule space) (assign-result e (match-zero-one (match-rule expression))) (result-expr (quasiquote (grammar-eval (unquote d) (unquote (car e)))))))))
(define-method $class <peg> () (let ((s)) (match-all (match-string "[") (assign-result s (make-string (match-zero-more (match-all (peek-not (match-string "]")) (match-rule char))))) (match-string "]") (match-rule space) (result-expr s))))
(define-method $string <peg> () (let ((s)) (match-all (match-string "\"") (assign-result s (make-string (match-zero-more (match-all (peek-not (match-string "\"")) (match-rule char))))) (match-string "\"") (match-rule space) (result-expr s))))
(define-method $char <peg> () (let () (match-first (match-all (match-string "\\") (match-first (match-all (match-string "t") (result-expr 9)) (match-all (match-string "n") (result-expr 10)) (match-all (match-string "r") (result-expr 13)) (match-all (match-string "x") (make-number 16 (make-span (match-all (match-rule higit) (match-rule higit))))) (match-all (match-string "u") (make-number 16 (make-span (match-all (match-rule higit) (match-rule higit) (match-rule higit) (match-rule higit))))) (match-any))) (match-any))))
(define-method $identifier <peg> () (let ((id)) (match-all (assign-result id (match-rule idpart)) (match-rule space) (result-expr id))))
(define-method $idpart <peg> () (let () (make-symbol (make-span (match-all (match-rule letter) (match-zero-more (match-first (match-rule letter) (match-rule digit))))))))
(define-method $letter <peg> () (let () (match-class "A-Z_a-z")))
(define-method $number <peg> () (let ((n)) (match-all (assign-result n (make-number 10 (make-span (match-all (match-zero-one (match-string "-")) (match-one-more (match-rule digit)))))) (match-rule space) (result-expr n))))
(define-method $higit <peg> () (let () (match-class "0-9A-Fa-f")))
(define-method $digit <peg> () (let () (match-class "0-9")))
(define-method $dot <peg> () (let () (match-all (match-string ".") (match-rule space))))
(define-method $rbrace <peg> () (let () (match-all (match-string "}") (match-rule space))))
(define-method $lbrace <peg> () (let () (match-all (match-string "{") (match-rule space))))
(define-method $rparen <peg> () (let () (match-all (match-string ")") (match-rule space))))
(define-method $lparen <peg> () (let () (match-all (match-string "(") (match-rule space))))
(define-method $star <peg> () (let () (match-all (match-string "*") (match-rule space))))
(define-method $plus <peg> () (let () (match-all (match-string "+") (match-rule space))))
(define-method $minus <peg> () (let () (match-all (match-string "-") (match-rule space))))
(define-method $query <peg> () (let () (match-all (match-string "?") (match-rule space))))
(define-method $at <peg> () (let () (match-all (match-string "@") (match-rule space))))
(define-method $dollar <peg> () (let () (match-all (match-string "$") (match-rule space))))
(define-method $dollardbl <peg> () (let () (match-all (match-string "$$") (match-rule space))))
(define-method $dollarhash <peg> () (let () (match-all (match-string "$#") (match-rule space))))
(define-method $comma <peg> () (let () (match-all (match-string ",") (match-rule space))))
(define-method $commaat <peg> () (let () (match-all (match-string ",@") (match-rule space))))
(define-method $backquote <peg> () (let () (match-all (match-string "`") (match-rule space))))
(define-method $quotesgl <peg> () (let () (match-all (match-string "'") (match-rule space))))
(define-method $arrow <peg> () (let () (match-all (match-string "->") (match-rule space))))
(define-method $colon <peg> () (let () (match-all (match-string ":") (match-rule space))))
(define-method $ampersand <peg> () (let () (match-all (match-string "&") (match-rule space))))
(define-method $pling <peg> () (let () (match-all (match-string "!") (match-rule space))))
(define-method $bar <peg> () (let () (match-all (match-string "|") (match-rule space))))
(define-method $space <peg> () (let () (match-zero-more (match-first (match-rule blank) (match-rule eol) (match-rule comment)))))
(define-method $comment <peg> () (let () (match-all (match-string "#") (match-zero-more (match-all (peek-not (match-rule eol)) (match-any))))))
(define-method $eol <peg> () (let () (match-first (match-all (match-string "\012") (match-zero-more (match-string "\015"))) (match-all (match-string "\015") (match-zero-more (match-string "\012"))))))
(define-method $blank <peg> () (let () (match-class "\011 ")))
(define-method $equals <peg> () (let () (match-all (match-string "=") (match-rule space))))
; parser bootstrap complete
; WARNING: unreachable from start: commaat
; WARNING: unreachable from start: comma
; WARNING: unreachable from start: minus
