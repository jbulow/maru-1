(define-structure <header> (size flags next))

(compile-begin)

(define exit	(extern 'exit))
(define malloc	(extern 'malloc))
(define memset	(extern 'memset))
(define printf	(extern 'printf))

(define gc_quantum	2048)
(define gc_frequency	8)

(define gc_root 0)

(define gc_memory_base 0)
(define gc_memory_last 0)
(define gc_alloc_count 0)

(define-form size-of-structure (type)	(* 4 (array-at %structure-sizes (eval type))))

(define-form <header>-flags-used ()	1)
(define-form <header>-flags-atom ()	2)
(define-form <header>-flags-mark ()	4)	(define-form <header>-flags-mark-mask ()	-5)

(define-form <header>-flags-used+atom ()	(+ (<header>-flags-used) (<header>-flags-atom)))

(define-function max (a b)	(if (> a b) a b))

(define-function new_memory_block (size)
  (let ((ptr (malloc size)))
    (or ptr
	(let ()
	  (printf "out of memory\n")
	  (exit 1)))
    (set (<header>-size  ptr) (- size (size-of-structure <header>)))
    (set (<header>-flags ptr) 0)
    (set (<header>-next  ptr) ptr)
    (printf "BRK %p %d\n" ptr size)
    ptr))

(define-function init_memory (size)
  (let ((ptr (new_memory_block size)))
    (set gc_memory_base ptr)
    (set gc_memory_last ptr)))

(define-function gc_grow_memory (size)
  (let ((brk (new_memory_block size)))
    (set (<header>-next brk)            (<header>-next gc_memory_last))
    (set (<header>-next gc_memory_last) brk)))

(define-function gc_malloc_chunk (size)
  (let ((ptr   (<header>-next gc_memory_last))
	(done  ())
	(chunk ()))
    (let ((lim ptr))
      (while (not done)
;; 	(printf "alloc? %d %p %p [%p] %d >= %d %d\n"
;; 		(<header>-flags ptr) ptr (<header>-next ptr) lim
;; 		(<header>-size ptr) size
;; 		(<= size (<header>-size ptr)))
	(if (and (=  0    (<header>-flags ptr))
		 (<= size (<header>-size  ptr)))
	    (let ()
	      (set chunk ptr)
	      (set done 1))
	  (set done (= lim (set ptr (<header>-next ptr)))))))
    ;;(printf "gc_malloc_chunk found free %p\n" chunk)
    (if chunk
	(let ((csize (<header>-size chunk)))
	  ;;(printf "CSIZE %d\n" csize)
	  (and (> csize (+ size (size-of-structure <header>)))
	       (let ((split (+ chunk (+ (size-of-structure <header>) size))))
		 ;;(printf "SPLIT %p\n" split)
		 (set (<header>-size  split) (- csize (+ size (size-of-structure <header>))))
		 (set (<header>-flags split) 0)
		 (set (<header>-next  split) (<header>-next chunk))
		 (set (<header>-size  chunk) size)
		 (set (<header>-next  chunk) split)))
	  (set (<header>-flags chunk) (<header>-flags-used))
	  (set gc_memory_last chunk)
	  ;;(printf "ALLOC CHUNK %p\n" chunk)
	  (let ((obj (+ chunk (size-of-structure <header>))))
	    (memset obj 0 size)
	    (set gc_alloc_count (+ gc_alloc_count 1))
	    obj)))))

(define-function gc_sweep (obj)
  ;;(printf "SWEEP\n")
  (let ((ptr gc_memory_base)
	(nused 0)
	(nfree 0))
    (while ptr
      ;;(printf "sweep? %d %p + %d\n" (<header>-flags ptr) ptr (<header>-size ptr))
      (let ((flags (<header>-flags ptr)))
	(if (& flags (<header>-flags-mark))
	    (let ()
	      (set nused (+ nused (<header>-size ptr)))
	      (set (<header>-flags ptr) (& flags (<header>-flags-mark-mask))))
	  ;;(printf "COLLECT %p %d\n" ptr (<header>-size ptr))
;; 	  (while (and (= 0 (& (<header>-flags-mark) (<header>-flags (<header>-next ptr))))
;; 		      (printf "%p + %d + %d = %p ? %p\n"
;; 			      ptr (size-of-structure <header>) (<header>-size ptr)
;; 			      (+ ptr (+ (size-of-structure <header>) (<header>-size ptr)))
;; 			      (<header>-next ptr))
;; 		      (= (<header>-next ptr) (+ ptr (+ (size-of-structure <header>) (<header>-size ptr)))))
;; 	    (let ((next (<header>-next (<header>-next ptr))))
;; 	      (printf "COALESCE %p < %p > %p\n" ptr (<header>-next ptr) next)
;; 	      (set (<header>-size ptr) (- (- next ptr) (size-of-structure <header>)))
;; 	      (set (<header>-next ptr) next)))
	  (set nfree (+ nfree (<header>-size ptr)))
	  (set (<header>-flags ptr) 0)))
      (and (= gc_memory_base (set ptr (<header>-next ptr)))
	   (set ptr 0)))
    (printf "%d used, %d free, %d allocations\n" nused nfree gc_alloc_count)
    (and (< nfree nused)
	 (gc_grow_memory gc_quantum))
    ))

(define-function gc_mark_and_trace (obj)
  (and obj
       (let* ((ptr   (- obj (size-of-structure <header>)))
	      (flags (<header>-flags ptr)))
	 (or (& flags (<header>-flags-mark))
	     (let ((size (>> (<header>-size ptr) 2)))
	       ;;(printf "mark %p %d\n" ptr size)
	       (while size
		 (set size (- size 1))
		 ;;(printf "@%d %p\n" size (oop-at obj size))
		 (gc_mark_and_trace (oop-at obj size)))
	       (set (<header>-flags ptr) (| flags (<header>-flags-mark))))))))

(define-function gc_gcollect ()
  (printf "GC\n")
  (gc_mark_and_trace gc_root)
  (gc_sweep)
  (set gc_alloc_count 0))

(define-function gc_malloc (size)
  (set size (& -4 (+ 3 size)))
  (and (= gc_alloc_count gc_frequency) (gc_gcollect))
  (or (gc_malloc_chunk size)
      (let ()
	(gc_grow_memory (max (+ (size-of-structure <header>) size) gc_quantum))
	(gc_malloc_chunk size))
      (let ()
	(printf "internal error: failed to allocate object after growing memory\n")
	(exit 1))))

(define-function gc_malloc_atomic (size)
  (let* ((obj (gc_malloc size)))
    (set (<header>-flags (- obj (size-of-structure <header>))) (<header>-flags-used+atom))
    obj))

(define-function main (argc argv)
  (init_memory gc_quantum)
  (printf "%p\n" gc_memory_base)
  (printf "%x\n" (<header>-size  gc_memory_base))
  (printf "%x\n" (<header>-flags gc_memory_base))
  (printf "%p\n" (<header>-next  gc_memory_base))
  (printf "%p\n" (set gc_root (gc_malloc 8)))
  (printf "%p\n" (gc_malloc 8))
  (printf "%p\n" (gc_malloc 8))
  (printf "%p\n" (gc_malloc 8))
  (let ((i 10000))
    (while (< i 1000)
      (printf "%p\n" (gc_malloc 1012))
      (set i (+ i 1))))
  0
  )

(compile-end)
