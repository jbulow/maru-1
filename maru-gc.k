(define (printf (int  	char * ...)		*)	(extern printf))
(define (exit	(void 	int)			*)	(extern exit))
(define (malloc	(void * long)			*)	(extern malloc))
(define (free	(void   void *)			*)	(extern free))
(define (memset	(void * void * int long)	*)	(extern memset))
(define (memcpy	(void * void * void * long)	*)	(extern memcpy))

(define-constant gc_quantum	65504)
(define-constant gc_frequency	32768)

(define-struct <gcheader>
  ((size	long)
   (flags	long)
   (next	struct <gcheader> *)))

(define-constant <gcheader>-flags-used      	 1)
(define-constant <gcheader>-flags-atom      	 2)
(define-constant <gcheader>-flags-mark      	 4)
(define-constant <gcheader>-flags-mask-no-mark	(- -1 <gcheader>-flags-mark))
(define-constant <gcheader>-flags-used+atom	(+ <gcheader>-flags-used <gcheader>-flags-atom))

(define (gc_roots	void * * *)	0)
(define (gc_root_count	int)		0)
(define (gc_root_max	int)		0)

(define (gc_memory_base	struct <gcheader> *)	0)
(define (gc_memory_last	struct <gcheader> *)	0)
(define (gc_alloc_count	long)			0)

(define-function max int ((a int) (b int))	(return (if (> a b) a b)))

(define-function fatal void ((reason char *))
  (printf "\n%s\n" reason)
  (exit 1))

(define-function new_memory_block (struct <gcheader> *) ((size long))
  (let (((ptr struct <gcheader> *) (malloc size)))
    (if (= ptr 0) (fatal "out of memory"))
    (set (. ptr size ) (- size (sizeof struct <gcheader>)))
    (set (. ptr flags) 0)
    (set (. ptr next ) ptr)
    (printf "BRK %p %d %d/%d\n" ptr size gc_alloc_count gc_frequency)
    (return ptr)))

(define-function gc_initialise void ()
  (let ((ptr (new_memory_block gc_quantum)))
    (set gc_memory_base ptr)
    (set gc_memory_last ptr)))

(define-function gc_push_root void ((ptr void *))
  (if (= gc_root_count gc_root_max)
      (let ((roots (malloc (* (sizeof void *) (set gc_root_max (* 2 gc_root_max))))))
	(memcpy roots gc_roots (* (sizeof void *) gc_root_count))
	(if (!= 0 gc_roots) (free gc_roots))
	(set gc_roots roots)))
  (set (indir gc_roots gc_root_count) ptr)
  (printf "gc add root %d at %p\n" gc_root_count ptr)
  (set gc_root_count (+ 1 gc_root_count)))

(define-function gc_pop_root void ((ptr void * *))
  (if (= 0 gc_root_count) (fatal "root table underflow"))
  (set gc_root_count (- gc_root_count 1))
  (printf "gc del root %d at %p\n" gc_root_count ptr)
  (if (!= ptr (indir gc_roots gc_root_count)) (fatal "non-lifo root")))

(define-function gc_grow_memory void ((size long))
  (let (((brk struct <gcheader> *) (new_memory_block size)))
    (set (. brk next)            (. gc_memory_last next))
    (set (. gc_memory_last next) brk)
    ))

(define-function gc_malloc_chunk (void *) ((size long))
  (let (( ptr				(. gc_memory_last next))
	((done	int)			0)
	((chunk struct <gcheader> *)	0))
    (let ((lim ptr))
      (while (! done)
;; 	(printf "alloc? %d %p %p [%p] %d >= %d %d\n"
;; 		(<header>-flags ptr) ptr (<header>-next ptr) lim
;; 		(<header>-size ptr) size
;; 		(<= size (<header>-size ptr)))
	(if (and (=  0    (. ptr flags))
		 (<= size (. ptr size)))
	    (let ()
	      (set chunk ptr)
	      (set done 1))
	  (set done (= lim (set ptr (. ptr next)))))))
    ;;(printf "gc_malloc_chunk found free %p\n" chunk)
    (if (!= 0 chunk)
	(let ((csize (. chunk size)))
	  ;;(printf "CSIZE %d\n" csize)
	  (and (> csize (+ size (sizeof (struct <gcheader>))))
	       (let ((split (+ chunk 1)))
		 ;;(printf "SPLIT %p\n" split)
		 (set (. split size ) (- csize (+ size (sizeof (struct <gcheader>)))))
		 (set (. split flags) 0)
		 (set (. split next ) (. chunk next))
		 (set (. chunk size ) size)
		 (set (. chunk next ) split)))
	  (set (. chunk flags) <gcheader>-flags-used)
	  (set gc_memory_last chunk)
	  ;;(printf "ALLOC CHUNK %p\n" chunk)
	  (let ((obj (+ chunk 1)))
	    (memset obj 0 size)
	    (set gc_alloc_count (+ gc_alloc_count 1))
	    (return obj)))
      (return 0))))

(define-function gc_sweep void ()
  ;;(printf "SWEEP\n")
  (let ((ptr gc_memory_base)
	(nused 0)
	(nfree 0))
    (while ptr
      ;;(printf "sweep? %d %p + %d\n" (<header>-flags ptr) ptr (<header>-size ptr))
      (let ((flags (. ptr flags)))
	(if (& flags <gcheader>-flags-mark)
	    (let ()
	      (set nused (+ nused (. ptr size)))
	      (set (. ptr flags) (& flags <gcheader>-flags-mask-no-mark)))
	  ;;(printf "COLLECT %p %d\n" ptr (<header>-size ptr))
;; 	  (while (and (= 0 (& (<header>-flags-mark) (<header>-flags (<header>-next ptr))))
;; 		      (printf "%p + %d + %d = %p ? %p\n"
;; 			      ptr (size-of-structure <header>) (<header>-size ptr)
;; 			      (+ ptr (+ (size-of-structure <header>) (<header>-size ptr)))
;; 			      (<header>-next ptr))
;; 		      (= (<header>-next ptr) (+ ptr (+ (size-of-structure <header>) (<header>-size ptr)))))
;; 	    (let ((next (<header>-next (<header>-next ptr))))
;; 	      (printf "COALESCE %p < %p > %p\n" ptr (<header>-next ptr) next)
;; 	      (set (<header>-size ptr) (- (- next ptr) (size-of-structure <header>)))
;; 	      (set (<header>-next ptr) next)))
	  (set nfree (+ nfree (. ptr size)))
	  (set (. ptr flags) 0)))
      (and (= gc_memory_base (set ptr (. ptr next)))
	   (set ptr 0)))
    (printf "%d used, %d free, %d allocations\n" nused nfree gc_alloc_count)
    (and (< nfree nused)
	 (gc_grow_memory gc_quantum))
    ))

(define-function gc_mark_and_trace void ((obj void *))
  ;;(printf "mark and trace %p\n" obj)
  (and obj
       (not (& (cast obj long) 1))
       (let* ((ptr   (- (cast obj struct <gcheader> *) 1))
	      (flags (. ptr flags)))
	 (or (& flags <gcheader>-flags-mark)
	     (let ((size (>> (. ptr size) 2)))
	       ;;(printf "mark %p %d\n" ptr size)
	       (while size
		 (set size (- size 1))
		 ;;(printf "@%d %p\n" size (oop-at obj size))
		 (gc_mark_and_trace (indir (cast obj void * *) size)))
	       (set (. ptr flags) (| flags <gcheader>-flags-mark)))))))

(define-function gc_gcollect void ()
  (let ((i 0))
    (while (< i gc_root_count)
      ;;(let ((ptr (oop-at gc_roots i))) (printf "mark gc root at %p -> %p\n" ptr (oop-at ptr 0)))
      (gc_mark_and_trace (indir (indir gc_roots i)))
      (set i (+ 1 i))))
  (gc_sweep)
  (set gc_alloc_count 0))

(define-function gc_malloc (void *) ((size long))
  (set size (& (- (sizeof void *)) (+ (- (sizeof void *) 1) size)))
  (and (= gc_alloc_count gc_frequency) (gc_gcollect))
  (let ((ptr (gc_malloc_chunk size)))
    (or ptr
	(let ()
	  (gc_grow_memory (max (+ (sizeof struct <gcheader>) size) gc_quantum))
	  (set ptr (gc_malloc_chunk size))))
    (or ptr
	(fatal "internal error: failed to allocate object after growing memory"))
    (return ptr)))

(define-function gc_malloc_atomic (void *) ((size long))
  (let ((obj (gc_malloc size)))
    (set (. (- (cast obj struct <gcheader> *) 1) flags) <gcheader>-flags-used+atom)
    (return obj)))

;; (define-function make_pair (head tail)
;;   (let ((cell (gc_malloc 8)))
;;     (set-oop-at cell 0 head)
;;     (set-oop-at cell 1 tail)
;;     ;;(printf "pair %p (%p %p) (%p %p)\n" cell head tail (oop-at cell 0) (oop-at cell 1))
;;     cell))

;; (define-function make_list (size)
;;   (if size
;;       (let ((list (make_list (- size 1))))
;; 	(gc_push_root (address-of list))
;; 	(set list (make_pair (| 1 (<< size 1)) list))
;; 	(gc_pop_root (address-of list))
;; 	list)))

;; (define-function print_list (list)
;;   (if 0 
;;   (if list
;;       (let ()
;; 	(printf "%p " list (oop-at list 0))
;; 	(print_list (oop-at list 1)))
;;     (printf "\n"))))

;; (define-function main (argc argv)
;;   (gc_initialise)
;;   (printf "%p\n" gc_memory_base)
;;   (printf "%x\n" (<header>-size  gc_memory_base))
;;   (printf "%x\n" (<header>-flags gc_memory_base))
;;   (printf "%p\n" (<header>-next  gc_memory_base))
;;   (printf "%p\n" (gc_malloc 8))
;;   (printf "%p\n" (gc_malloc 8))
;;   (printf "%p\n" (gc_malloc 8))
;;   (printf "%p\n" (gc_malloc 8))
;;   (let ((i   0))
;;     (let ((obj 0))
;;       (gc-protect (obj)
;; 	(while (< i 1000)
;; 	  (print_list (set obj (make_list 256)))
;; 	  (set i (+ i 1)))
;; 	(gc_gcollect))
;;       (gc_gcollect)
;;       ))
;;   0
;;   )

(define main (lambda int ((argc int) (argv char * *))
  (printf "%d %d\n" gc_quantum gc_frequency)
  (printf "%d %d %d %d %d\n"
	  <gcheader>-flags-used
	  <gcheader>-flags-atom
	  <gcheader>-flags-mark
	  <gcheader>-flags-mask-no-mark
	  <gcheader>-flags-used+atom)
  (gc_initialise)
  (return 0)))

(compile-end) (exit)
