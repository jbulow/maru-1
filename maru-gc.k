(define-form gcdebug (exp)	exp)
(define-form debug (exp)	());exp)
(define-form safe  (exp)	exp)

(define (printf (int  	char * ...)		*)	(extern printf))
(define (exit	(void 	int)			*)	(extern exit))
(define (malloc	(void * long)			*)	(extern malloc))
(define (free	(void   void *)			*)	(extern free))
(define (memset	(void * void * int long)	*)	(extern memset))
(define (memcpy	(void * void * void * long)	*)	(extern memcpy))

(define-constant gc_quantum	(* 50 1024))
(define-constant gc_frequency	32768)

(define-struct <header> ((size long) (flags long) (next struct <header> *) (type long)))

(define-constant <header>-flags-used		1)
(define-constant <header>-flags-atom		2)
(define-constant <header>-flags-used+atom	3)
(define-constant <header>-flags-mark		4)

(define (gc_memory_base		struct <header> *)	0)
(define (gc_memory_last		struct <header> *)	0)
(define (gc_alloc_count		long)			0)
(define (gc_root_count		long)			0)
(define (gc_roots		void * * *)		0)
(define (gc_root_max		long)			0)
(define (gc_objects_live	long)			0)
(define (gc_bytes_used		long)			0)
(define (gc_bytes_free		long)			0)
(define (gc_allocation_count	long)			0)
(define (gc_collection_count	long)			0)

(define-function fatal void ((reason char *))	(printf "\nmaru: %s\n" reason) (exit 1))

(define-function max long ((a long) (b long))	(return (if (>= a b) a b)))

(define-function new_memory_block (void *) ((size long))
  (let ((ptr (cast (malloc size) struct <header> *)))
    (or ptr (fatal "out of memory"))
    (set (. ptr size ) (- size (sizeof struct <header>)))
    (set (. ptr flags) 0)
    (set (. ptr next ) ptr)
    (debug (printf "BRK %p %d %d/%d\n" ptr size gc_alloc_count gc_frequency))
    (return ptr)))

(define-function gc_initialise void ()
  (let ((ptr (new_memory_block gc_quantum)))
    (set gc_memory_base ptr)
    (set gc_memory_last ptr)))

(define-function gc_push_root void ((ptr void *))
  (and (= gc_root_count gc_root_max)
       (let ((roots (malloc (* (sizeof void *) (set gc_root_max (max 32 (* 2 gc_root_max)))))))
	 (memcpy roots gc_roots (* (sizeof void *) gc_root_count))
	 (and gc_roots (free gc_roots))
	 (set gc_roots roots)))
  (set (indir gc_roots gc_root_count) ptr)
  (debug (printf "gc PUSH root %d at %p\n" gc_root_count ptr))
  (set gc_root_count (+ 1 gc_root_count)))

(define-function gc_pop_root void ((ptr void *))
  (or gc_root_count (fatal "root table underflow"))
  (set gc_root_count (- gc_root_count 1))
  (debug (printf "gc POP  root %d at %p\n" gc_root_count ptr))
  (or (= ptr (indir gc_roots gc_root_count)) (fatal "non-lifo root")))

(define-function gc_grow_memory void ((size long))
  (let ((brk (cast (new_memory_block size) struct <header> *)))
    (set (. brk            next) (. gc_memory_last next))
    (set (. gc_memory_last next) brk)))

(define-function gc_size long ((obj void *))
  (return (. (- (cast obj struct <header> *) 1) size)))

(define-function gc_sweep void ()
  (debug (printf "sweep\n"))
  (let ((ptr gc_memory_base)
	(nobjs 0)
	(nused 0)
	(nfree 0))
    (while ptr
      (debug (printf "sweep? %d %p + %d\n" (. ptr flags) ptr (. ptr size)))
      (let ((flags (. ptr flags)))
	(if (& flags <header>-flags-mark)
	    (let ()
	      (set nused (+ nused (. ptr size)))
	      (set nobjs (+ nobjs 1))
	      (set (. ptr flags) (^ flags <header>-flags-mark)))
	  (debug (printf "collect %p %d\n" ptr (. ptr size)))
	  (set nfree (+ nfree (. ptr size)))
	  (set (. ptr flags) 0)))
      (and (= gc_memory_base (set ptr (. ptr next)))
	   (set ptr 0)))
    (set gc_objects_live nobjs)
    (set gc_bytes_used   nused)
    (set gc_bytes_free   nfree)
    (debug (printf "GC: %d used, %d free, %d allocations\n" nused nfree gc_alloc_count))
    ))

(define-function gc_mark_and_trace void ((obj void *))
  (and obj
       (not (& 1 (cast obj long)))
       (let* ((ptr   (- (cast obj struct <header> *) 1))
	      (flags (. ptr flags)))
	 (debug (printf "mark and trace %p flags %d\n" obj flags))
	 (safe (or (& <header>-flags-used flags) (fatal "attempt to mark dead object")))
	 (or (& flags <header>-flags-mark)
	     (let ()
	       (set (. ptr flags) (| flags <header>-flags-mark))
	       (or (& flags <header>-flags-atom)
		   (let ((size (>> (. ptr size) 2)))
		     (debug (printf "mark %p %d type %d\n" ptr size (. ptr type)))
		     (while size
		       (set size (- size 1))
		       (debug (printf "@%d %p\n" size (indir (cast obj void * *) size)))
		       (gc_mark_and_trace (indir (cast obj void * *) size))))))))))

(define-function gc_gcollect void ()
  (gcdebug
    (or (& 1023 (set gc_collection_count (+ gc_collection_count 1)))
	(printf "%d collections\n" gc_collection_count 1)))
  (let ((i 0))
    (while (< i gc_root_count)
      (debug (let ((ptr (indir gc_roots i))) (printf "mark gc root %d : %p -> %p\n" i ptr (indir ptr))))
      (gc_mark_and_trace (indir (indir gc_roots i)))
      (set i (+ 1 i))))
  (gc_sweep)
  (set gc_alloc_count 0))

(define-function gc_malloc (void *) ((size long))
  (set size (& -4 (+ 3 size)))
  (and (= gc_alloc_count gc_frequency) (gc_gcollect))
  (let* ((first (. gc_memory_last next))
	 (chunk first)
	 (ssize (+ size (sizeof struct <header>))))
    (while 1
      (while
	(let ()
	  (debug (printf "alloc? %d %p %p [%p] %d >= %d %d\n" (. chunk flags) chunk (. chunk next) first (. chunk size) size (<= size (. chunk size))))
	  (if (= 0 (. chunk flags))
	      (let ((csize (. chunk size)))
		(while (and (= 0 (. (. chunk next) flags))
			    (= (. chunk next) (+ chunk 1)))
		  (let ((next (. chunk next)))
		    (set (. chunk next) (. next next))
		    (set csize (set (. chunk size) (+ csize (+ (sizeof struct <header>) (. next size)))))
		    (and (= next gc_memory_last) (set gc_memory_last chunk))))
		(if (or (< ssize csize) (= size csize))
		    (let ()
		      (debug (printf "csize %d\n" csize))
		      (and (> csize ssize)
			   (let ((split (cast (+ (cast chunk void *) ssize) (struct <header> *))))
			     (debug (printf "split %d: %p + %d -> %p + %d\n" csize chunk size split (- csize (+ size (sizeof struct <header>)))))
			     (set (. split size ) (- csize (+ size (sizeof struct <header>))))
			     (set (. split flags) 0)
			     (set (. split next ) (. chunk next))
			     (set (. chunk size ) size)
			     (set (. chunk next ) split)
			     (set csize size)))
		      (set (. chunk flags) <header>-flags-used)
		      (set gc_memory_last chunk)
		      (debug (printf "alloc chunk %p\n" chunk))
		      (let ((obj (+ chunk 1)))
			(memset obj 0 csize)
			(set gc_alloc_count (+ gc_alloc_count 1))
			(set gc_allocation_count (+ gc_allocation_count 1))
			(return obj))))))
	  (!= first (set chunk (. chunk next)))))
      (gc_grow_memory (max (+ (sizeof struct <header>) size) gc_quantum))))
  (return 0))

(define-function gc_malloc_atomic (void *) ((size long))
  (let ((obj (gc_malloc size)))
    (set (. (- (cast obj struct <header> *) 1) flags) <header>-flags-used+atom)
    (return obj)))

;;; ----------------------------------------------------------------

(let ((make-push-root (lambda (v) `(gc_push_root (addressof ,v))))
      (make-pop-root  (lambda (v) `(gc_pop_root  (addressof ,v)))))
  (define-form gc-protect (vars . body)
    `(let ()
       ,@(map make-push-root vars)
       ,@body
       ,@(reverse-map make-pop-root vars))))

(define-struct <cell> ((head int) (tail struct <cell> *)))

(define-function make_cell (struct <cell> *) ((head int) (tail struct <cell> *))
  (let ((cell (cast (gc_malloc 8) struct <cell> *)))
    (set (. cell head) head)
    (set (. cell tail) tail)
    ;;(printf "pair %p (%p %p) (%p %p)\n" cell head tail (oop-at cell 0) (oop-at cell 1))
    (return cell)))

(define-function make_list (struct <cell> *) ((size int))
  (if size
      (let ((list (make_list (- size 1))))
	(gc_push_root (addressof list))
	(set list (make_cell (| 1 (<< size 1)) list))
	(gc_pop_root (addressof list))
	(return list))
    (return 0)))

(define-function print_list void ((list struct <cell> *))
  (if list
      (let ()
	(printf "%08x.%-5i      " list (. list head))
	(print_list (. list tail)))
    (printf "\n")))

(define-function info void ()
  (printf "GC: %d used, %d free, %d allocations, %d collections, %d live\n"
	  gc_bytes_used gc_bytes_free gc_allocation_count gc_collection_count gc_objects_live))

(define-function main int ((argc int) (argv char * *))
  (gc_initialise)
  (let ((i   0)
	(obj (cast 0 struct <cell> *)))
    (gc-protect (obj)
      (while (< i 10000)
	(unless (% i 1000) (info))
	(set obj (make_list 256))
	;;(print_list obj)
	(set i (+ i 1)))
      (gc_gcollect)
      ))
  (gc_gcollect)
  (info)
  (return 0)
  )

(compile-end)
(exit)
