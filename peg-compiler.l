(define-structure <peg-compiler> (grammar indent))

(define-function peg-compiler (grammar)
  (with-instance-accessors <peg-compiler>
    (let ((self (new <peg-compiler>)))
      (set self.grammar grammar)
      (set self.indent 0)
      self)))

(define-selector $compile)
(define-selector $declare)
(define-selector $define)
(define-selector $find-variables)
(define-selector $emit)
(define-selector $begin)
(define-selector $end)
(define-selector $gen)
(define-selector $match-both)
(define-selector $match-rule)
(define-selector $match-first)
(define-selector $match-object)
(define-selector $match-class)
(define-selector $assign-result)
(define-selector $match-zero-more)
(define-selector $match-one-more)
(define-selector $result-variable)
(define-selector $result-list-variable)
(define-selector $match-zero-one)
(define-selector $result-list-symbol)
(define-selector $result-list)
(define-selector $make-symbol)
(define-selector $make-string)
(define-selector $make-span)
(define-selector $match-string)
(define-selector $match-any)
(define-selector $peek-not)
(define-selector $result-list-variable-splicing)
(define-selector $result-object)
(define-selector $peek-for)

(define-method $compile <peg-compiler> ()
  ($emit self "(define-class "(<grammar>-name self.grammar)" "(<grammar>-base self.grammar)" "(<grammar>-fields self.grammar)")")
  (with-map $declare self (<grammar>-rules self.grammar))
  (with-map $define  self (<grammar>-rules self.grammar)))

(define-method $emit <peg-compiler> args
  (for (i 0 self.indent) (print "  "))
  (apply println args))

(define-method $begin <peg-compiler> args
  (for (i 0 self.indent) (print "  "))
  (apply println args)
  (set self.indent (+ self.indent 1)))

(define-method $end <peg-compiler> args
  (for (i 0 self.indent) (print "  "))
  (apply println args)
  (set self.indent (- self.indent 1)))

(define-method $declare <peg-compiler> (rule)
  ($emit self "(define-selector $"(car rule)") ;; forward"))

(define-method $define <peg-compiler> (rule)
  (let ((vars ($find-variables self (cadr rule) ())))
    ($begin self "(define-method $"(car rule)" "(<grammar>-name self.grammar)" ()")
    (and vars ($begin self "(let "vars))
    ($gen   self (cadr rule))
    (and vars ($end   self")"))
    ($end   self")")))

(define-method $find-variables <peg-compiler> (tree vars)
  (and (pair? tree)
       (if (= (car tree) 'assign-result)
	   (or (assq (cadr tree) vars)
	       (set vars (cons (cadr tree) vars)))
	 (let ((e1 (cadr tree))
	       (e2 (caddr tree)))
	   (set vars ($find-variables self e1 vars))
	   (set vars ($find-variables self e2 vars)))))
  vars)

(define-method $gen <peg-compiler> (tree)
  ;;(println "- " tree)
  (let ((op (car tree)))
    (cond
      ((= op 'match-both)			($match-both			self tree))
      ((= op 'match-rule)			($match-rule			self tree))
      ((= op 'match-first)			($match-first			self tree))
      ((= op 'match-object)			($match-object			self tree))
      ((= op 'match-class)			($match-class			self tree))
      ((= op 'assign-result)			($assign-result			self tree))
      ((= op 'match-zero-more)			($match-zero-more		self tree))
      ((= op 'match-one-more)			($match-one-more		self tree))
      ((= op 'result-variable)			($result-variable		self tree))
      ((= op 'result-list-variable)		($result-list-variable		self tree))
      ((= op 'match-zero-one)			($match-zero-one		self tree))
      ((= op 'result-list-symbol)		($result-list-symbol		self tree))
      ((= op 'result-list)			($result-list			self tree))
      ((= op 'make-symbol)			($make-symbol			self tree))
      ((= op 'make-string)			($make-string			self tree))
      ((= op 'make-span)			($make-span			self tree))
      ((= op 'match-string)			($match-string			self tree))
      ((= op 'match-any)			($match-any			self tree))
      ((= op 'peek-not)				($peek-not			self tree))
      ((= op 'result-list-variable-splicing)	($result-list-variable-splicing self tree))
      ((= op 'result-object)			($result-object			self tree))
      ((= op 'peek-for)				($peek-for			self tree))
      (else					(error "peg-compile does not understand "op)))))

(define-method $match-both <peg-compiler> (tree)
  ($begin self "(let ((pos (<parser-stream>-position self.source)))")
  ($begin self "(or")
  ($begin self "(and")
  (while (let ()
	   ($gen self (cadr tree))
	   (= 'match-both (caaddr tree)))
    (set tree (caddr tree)))
  ($gen   self (caddr tree))
  ($end   self ")")
  ($end   self "(parser-stream-fail self.source pos))")
  ($end   self ")"))

(define-method $match-rule <peg-compiler> (tree)
  ($emit self "($"(cadr tree)" self)"))

(define-method $match-first <peg-compiler> (tree)
  ($begin self "(or")
  (while (let ()
	   ($gen self (cadr tree))
	   (= 'match-first (caaddr tree)))
    (set tree (caddr tree)))
  ($gen   self (caddr tree))
  ($end   self ")"))

(define-method $match-object <peg-compiler> (tree)
  ($emit self "(and (= "(cadr tree)" (parser-stream-peek self.source)) (set self.result (parser-stream-next self.source)))"))

(define-method $match-class <peg-compiler> (tree)
  ($emit self "(set self.result (parser-stream-match-class self.source \""(cadr tree)"\"))"))

(define-method $assign-result			<peg-compiler> (tree)	($emit self "(let () (set "(cadr tree)" self.result) 't)"))

(define-method $match-zero-more <peg-compiler> (tree)
  ($begin self "(let ((_list_ (group)))")
  ($begin self "(while")
  ($gen   self (cadr tree))
  ($end   self "(group-append _list_ self.result))")
  ($end   self "(set self.result _list_))"))

(define-method $match-one-more <peg-compiler> (tree)
  ($begin self "(let ((_list_ (group)))")
  ($begin self "(while")
  ($gen   self (cadr tree))
  ($end   self "(group-append _list_ self.result))")
  ($end   self "(and (not (group-empty _list_)) (set self.result _list_)))"))

(define-method $result-variable <peg-compiler> (tree)
  ($emit self "(let () (set self.result "(cadr tree)") 't)"))

(define-method $result-list-variable <peg-compiler> (tree)
  ($emit self "(group-append _list_ "(cadr tree)")"))

(define-method $match-zero-one <peg-compiler> (tree)
  ($begin self "(let ((_list_ (group)))")
  ($begin self "(and")
  ($gen   self (cadr tree))
  ($end   self "(group-append _list_ self.result))")
  ($end   self "(set self.result _list_))"))

(define-method $result-list-symbol <peg-compiler> (tree)
  ($emit self "(group-append _list_ '"(cadr tree)")"))

(define-method $result-list <peg-compiler> (tree)
  ($begin self "(let ((_list_ (group)))")
  (with-map $gen self (cdr tree))
  ($end self "(set self.result _list_))"))

(define-method $make-symbol <peg-compiler> (tree)
  ($begin self "(and")
  ($gen   self (cadr tree))
  ($end   self "(set self.result (string->symbol (group->string self.result))))"))

(define-method $make-string <peg-compiler> (tree)
  ($begin self "(and")
  ($gen   self (cadr tree))
  ($end   self "(set self.result (group->string self.result)))"))

(define-method $make-span <peg-compiler> (tree)
  ($begin self "(let ((pos (<parser-stream>-position self.source)))")
  ($begin self "(and")
  ($gen   self (cadr tree))
  ($end   self "(set self.result (group-from-to pos (<parser-stream>-position self.source))))")
  ($end   self ")"))

(define-method $match-string <peg-compiler> (tree)
  ($emit self "(set self.result (parser-stream-match-string self.source \""(cadr tree)"\"))"))

(define-method $match-any <peg-compiler> (tree)
  ($emit self "(set self.result (parser-stream-next self.source))"))

(define-method $peek-not <peg-compiler> (tree)
  ($begin self "(let ((pos (<parser-stream>-position self.source)))")
  ($begin self "(if")
  ($gen   self (cadr tree))
  ($emit  self "(parser-stream-fail self.source pos)")
  ($end   self "'t)")
  ($end   self ")"))

(define-method $result-list-variable-splicing <peg-compiler> (tree)
  ($emit self "(group-append-all _list_ "(cadr tree)")"))

(define-method $result-object <peg-compiler> (tree)
  ($emit self "(let () (set self.result "(cadr tree)") 't)"))

(define-method $peek-for <peg-compiler> (tree)
  ($begin self "(let ((pos (<parser-stream>-position self.source)))")
  ($begin self "(and")
  ($gen   self (cadr tree))
  ($end   self "(set (<parser-stream>-position self.source) pos))")
  ($end   self ")"))
